20 Seiten

# Titel

Implementierung eines RISC-V CPU und Bestandteilen einer Toolchain

# Zielsetzung

Das Ziel dieser Studienarbeit ist es einen Weg und die Mittel aufzuzeigen, mit denen ein Anfänger die Erstellung es einfachen RISC-V CPU bewerkstelligen kann. Das Testen des CPU durch selbstentwickelte Software und das Debuggen der Software auf dem CPU ist ebenfalls Teil der gesetzten Aufgabe.

# Herausforderungen

Die Implementierung eines RISC-V CPU stellt einen Student vor mehrere Herausforderungen.

1. Auswahl der Hardware - Ein FPGA Entwicklungsboard kann zwar von der Bildungseinrichtung beigestellt werden und die Auswahl ist damit vorgegeben. Es kann trotzdem sinnvoll sein sich nochmals über die Wahl des Entwicklungsboards gedanken zu machen, da die Auswahl des Entwicklungsboards Einfluss auf die zu verwendende FPGA-Entwicklungstools hat. Die Verwendung bestimmter FPGA-Entwicklungstools haben selbst wiederum Konsequenzen und will daher gut ausgewählt werden. Ein weiterer Punkt ist der Preis und die Verfügbarkeit der FPGA Boards. Es gibt bereits Boards zu niedrigen Kosten, die sich für das Erlernen der FPGA-Entwicklung eignen.

2. Auswahl der FPGA-Entwicklungstools - Die FPGA Entwicklungstools können vom Hersteller des FPGA gestellt werden. Diese Herstellertools sind im Falle von Vivado (Vom Hersteller AMD für Artix, Kintex, Virtex, Spartan und Zynq 7000 series und auch UltraScale and UltraScale+ Familien) und Quartus Prime (Intel für Cyclone und MAX chips) sehr umfangreich. Vorteile von Intel und AMD sind die Bereitstellung von IP-Bibliotheken und Generatoren. Nachteile sind die schiere Größe dieser Tools (mehrer 100 GB an Festplatten für die Installation). Ein mittleres Angebot wird von kleineren Herstellern wie der Firma Lattice und der Firma GOWIN gemacht. Ihre FPGAs sind teilweiße durch OpenSource Toolchains abgedeckt aber die Herstellereignenen FPGA-Entwicklungstools sind auch eine gute Option und bieten oft einen guten Funktionsumfang bei kleinerem Resourcenverbrauch. Des weiteren geht die Bandbreite bis hin zu OpenSource Tools (Yosys, NextPNR). Die Toolchains werden in einem späteren Abschnitt miteinander verglichen und eine Auswahl wird getroffen.

3. Erlernen der HDLs Verilog, System Verilog oder VHDL. Ausführen von Simulationen und übertragen der Designs auf den FPGA und dortigem Test. Es kann sein, dass Designs trotz funktionierende Simulation nicht auf dem FPGA funktionieren. Die Fehlersuche ist dann sehr schwer, da es keine "Debugger" für FPGAs und deren internen Abläufe gibt. Von Vorteil ist es, wenn die Dauer eines Zyklus von der Änderung des Designs über die Synthese bis zum Upload kurz sind. Verständnis vom Design für Signales (wires) und getackteter, Zustandsbehafteter Logik (register mit clock Flanken).

Auch nachdem die Aufgabe des Designs eines CPU gemeistert ist, gibt es weitere Herausforderungen.

4. Auswahl eines Assemblers - Es gibt wenige Assembler, die RISC-V code in Maschinenbefehle übersetzen und dabei möglichst wenige Annahmen treffen.
Das Problem liegt in einer Diskrepanz zwischen der RISC-V Spezifikation und Lehrbüchern zu RISC-V und den Compilern und Assemblern, die tatsächlich zur Erstellung von Software gentzt werden. Die RISC-V Spezifikation und Lehrbücher sprechen über RISC-V Instruktionen und deren Kodierung in Maschinenbefehle. Wirkliche Compiler haben die Aufgabe Maschinencode auszugeben, der konkrete Speicherbereiche belegt und die Kombination von unterschiedlichen Objektfiles in ein kombiniertes Programm ermöglicht. Für einen Anfänger kann diese Diskrepanz zu einer zusätzlichen Herausforderung werden, für die er nicht die notwendige Zeit oder Motivation hat. Ein echter Compiler benötigt beispielsweiße noch ein Linkerscript bevor er arbeitet. Wenn man eine RISC-V CPU entwirft, möchte man eventuel lediglich simple Testprogramme von Addresse 0x00 ausführen und legt keinen Wert auf Adressbereiche. es soll ein Assembler für 32-bit RISC-V bereitgestellt werden, mit dem schnell, unkompliziert und ohne Annahmen RISC-V Assemblercode in Maschinenbefehle für den Upload in den CPU übersetzt werden kann.

5. Interaktion mit dem CPU - Wenn das Design über den Bitstream auf den FPGA bereitgestellt worden ist, wird der CPU ein Programm ausführen. Die Frage ist, wie man jetzt mit dem CPU interagiert. Das Ziel ist es nicht Peripherie wie Druckknöpfe, LEDs oder LCDs an den CPU anschließen, sondern mit dem CPU selbst zu kommunizieren. Nach Möglichkeit soll der CPU gestoppt und gestartet werden können. Der Zugriff auf Register soll möglich sein und der Zugriff auf den Speicher soll möglich sein. Dazu gibt es die Debug-Spezifikation für RISC-V (TODO: Referenz auf eine bestimmte Version der Debug-Spek hier einfügen! file:///C:/Users/lapto/dev/fpga/gowin_tang_nano/riscv_debug/doc/riscv-debug-release.pdf). Die Debug-Spezifikation beschreibt Komponenten um mit den Harts eines RISC-V CPU zu interagieren. Die Kommunikation kann über das JTAG-Protokoll ausgeführt werden. In diesem Bericht wird ein Teil der RISC-V Debug Spezifikation implementiert, gerade genug um die oben geforderten Punkte über eine JTAG DebugProbe auszuführen.

# 0. Einleitung zu RISC-V

RISC-V ist eine Instruction Set Architecture (ISA). Ein Instructionset Architecture ist eine Menge an Anweisungen, Registern und Datentypen. Damit beschreibt RISC-V keine konkrete CPU Architektur sondern gibt Befehle und Register vor, die auf einer konkreten Architektur ausführbar und vorhanden sein müssen, damit dieses System RISC-V konform ist. Laut der RISC-V homepage (Quelle: https://riscv.org > about > faq > Who uses an ISA?) ist eine ISA auch im Zuge der Leere einsetzbar damit Stunden die Wirkungsweiße eines Computers verstehen lernen. RISC-V wurde daher auch vor dem Hintergrund der Leere erstellt.

Damit steht RISC-V in Konkurrenz mit dem x86 Instructionset (Chips von Intel, AMD und weiteren), dem ARM Instructionset (Chips von STM32, Renesas, NXP, Qualcomm und andere) und allen anderen definierten Instructionsets (AVR, Itanium (IA-64), MIPS, Z-80 und viele weitere). Die Besonderheit von RISC-V ist das Lizenzmodel. Das Lizenzmodel besteht aus der Erlaubnis zur freien Benutzung und damit der Abwesenheit jeglicher Lizenzkosten (Quelle: https://riscv.org/about/faq/#:~:text=There%20is%20no%20fee%20to%20use%20the%20RISC%2DV%20ISA. In Google eingeben: https://riscv.org > about > faq > What is the license model ).

RISC-V ist an der Universität UC Berkeley entwickelt worden. Dabei ist RISC-V aus dem Wissenschatz erstellt worden, den die Beteiligten im Zuge der vier Vorgängeprojekte (RISC-I bis RISC-4) sammeln konnten und heißt damit sinnigerweiße RISC-V (Quelle: https://riscv.org > about > faq > Why is it called RISC-V).

RISC-V hat in den letzten Jahren weitere Fortschritte gemacht. Das Tripple-A Spiel "The Witcher 3" lässt sich mit Einschränkungen auf einem RISC-V System (https://milkv.io/pioneer) ausführen. RISC-V Mainline Support wurde Linux im Jahre 2022 hinzugefügt. Die 64 Bit Variante von RISC-V hielt im Jahre 2023 Einzug in den Linux-Kernel (Quelle: https://en.wikipedia.org/wiki/RISC-V)

Die RISC-V ISA ist keine monoithische Spezifikation. Das angewandte Prinzip ist, dass ein Kern von Funktionen für eine gewisse Bit-Breite (XLEN) vorhanden sein muss, der dann durch Extensions erweitert werden kann. Beispiele für Kerne sind RV32I, RV64I und RV128I die Integer-Operationen mit jeweilgen Registerbreiten von 32, 64 und 128 Bit unterstützen. Extensions fügen dem System Floating-Point Unterstützung, Komprimierte Anweisungen, Vector-Mathematik, Kryptografie, Atomic-Operationen und viele weitere Funktionen hinzu.

In dieser Studienarbeit wird ein Teil des Kerns RV32I umgesetzt. Dieser Umfang kann durch weitere Entwicklungstätigkeit immer weiter bis zum vollem Umfang von RV32I ergänzt werden wenn notwendig. Als Extensions wird die Debug-Spezifikation hinzugefügt.

# 1. Auswahl der Hardware

- Lattice IceStick
- GOWIN TangNano 9k
- Digilent  ARTY S7
- DE 112

Kriterien: 
 - RAM; 
 - LUTs - Passt ein RISC-V Design auf den FPGA
 - Formfaktor (passt es auf den Tisch, kann man es leicht in einem Rucksack mitnehmen z.B. zwischen Hochschule und Wohnung)
 - Wieviel Perihperie hat es (Hat es PMOD, LEDs, Breakout Pins).
 - Anschaffungskosten
 - Freie Software

# 2. Auswahl der FPGA-Entwicklungstools

Kriterien zur Bewertung von FPGA Entwicklungstools

- Installationsplattenplatz (100-te GB sind schlecht!)
- Unterstützung von Simulationstools und Traceviewer on board
- Geschwindigkeit der Synthese (allgemeine Performance des Tools)
- Fehlererkennung der Synthese (logische Loops werden von Yosys nicht erkannt! Vom professionellen Tool schon)
- Editorqualität (go to definition, highlight von gehovertem Symbol, ...)

Da diese Studienarbeit Lösungen für den Student in einem der unteren Semester sucht, muss davon ausgegangen werden, dass dieser Student keine High-End Hardware zur Verfügung hat um erste Tests mit Hardwarebeschreibungssprachen zu machen und auch nicht bereit ist oder in der finanziellen Situation ist um sich High-End Hardware zu kaufen. Das wahrscheinlichste Szenario ist, dass die Hardware ein Laptop mittlerer Leistungsklasse mit einem Windows-Betriebssystem ist. Im folgenden werden die Messungen auf einem AMD Ryzen 7 PRO 4750U mit 32GB RAM ausgeführt. Die acht Kerne (16 Threads) haben einen Basistakt von 1,7 GHz und einen Boosttakt von 4,1 GHz. Der Prozessor besitzt 512 KB L1 Cache, 4 MB L2 Cache und 8 MB L3 Cache. Das System stamt aus dem Jahr 2020. Die Messungen werden unter Windows 11 Pro, 24H2 (OS build 26100.4349) ausgeführt. Bezüglich der Festplattenkapazität ist mit 250 GB zu rechnen, von denen wahrscheinlich in der Realität nicht mehr viel Platz übrig ist. In dieser Arbeit wird daher auch Augenmerk auf den benötigten Speicherbedarf der Tools gelegt.

# Lattice iCEstick (https://www.latticesemi.com/icestick)
Der iCEstick der Firma Lattice ist ein FPGA im USB-Stick Format. Damit nimmt er kaum Platz auf dem Schreibtisch ein und kann leicht transportiert weren. Der Anschaffungspreis liegt bei etwa 130-150 Euro. Damit ist der Lattice iCEstick vergleichsweiße teuer. Die Peripherie weißt leider nur wenige Breakout Pins auf, dafür besitzt das Board einen einzigen PMOD Header und 5 LEDs, sowie einen Infrarot IrDA Sensor. Der iCEstick besitzt einen Lattice iCE40HX-1k FPGA chip (https://www.mouser.de/ProductDetail/Lattice/iCE40HX1K-TQ144?qs=F9A14TELRMtiYSwGl6R%2Fcw%3D%3D&srsltid=AfmBOopRdilmfbmh3HyTAYo1qr89NC4w5Ca6M5ykeBUMYd6rbPP2OnCq). Auf dem FPGA hat ein kleiner RISC-V CPU Platz (siehe https://github.com/BrunoLevy/learn-fpga und das FemotRV Projekt). Die offizielle IDE ist iCEcube2 und kann auf Microsoft Windows ausgeführt werden. Der Download von iCEcube2 ist 700MB groß und zur Installtion werden 880MB benötigt. Damit ist das Softwarepacket insgesamt vergleichsweiße klein. Zum Programmieren des Bitstream wird die Diamond Programmer Software verwendet, der den Bitsream in das OnBoard SPI Flash schreibt. Die iCEcube2 Software benötigt einen Lizenz zur Ausführung. Die Lizenz wird auf Anfrage an nicht-kommerzielle Entwickler und Start-Ups ausgegegben. Normalerweiße kostet diese Lizenz Geld. 

Als Alternative zur Software des Herstellers kann die OpenSource Toolchain Yosys (https://github.com/YosysHQ/yosys) verwendet werden. Yosys kann in einer für Windows vorgefertigten Version von https://yosyshq.net/yosys/download.html heruntergeladen werden. Yosys ist ein Sammlung an Kommandozeilentools um Verilog zu Synthetisieren, eine Bitstream zu erzeugen und den Bitstream auf die unterstützten FPGAs zu laden. Vorteile von Yosys sind der schnelle und unkomplizierte Download, der mit 303 MB sehr kompakt ist. Ein weiterer Vorteil ist die relativ schnelle Synthese-Zeit. Die Nachteile von Yosys sind die mangelhafte Erkennung und Ausgabe kritischer Fehler und die fehlende Option IPs einzusetzen. Der Nachteil ohne IP ist, dass ein Speicherblock vom Tool als Speicher erkannt werden muss. Diese Erkennung führt das Tool implizit automatisch aus und der Benutzer muss hoffen, dass sein Design als Speicher erkannt wird. Es gibt Vorgegebene Verilog Designs, die Yosys als Speicher erkennen soll. Nicht immer funktioniert die Erkennung automatisch. Wenn ein Speicher nicht als Speicher IP erkannt wird, wird er Bitstream nicht durch Hardware im FPGA implementiert werden. Wenn diese Situation eintritt, synthetisiert Yosys Speicher durch Logikblöcke und belegt damit direkt große Mengen an Resourcen auf dem FPGA, die dann nicht mehr für echte Logik zur Verfügung stehen! Um die Speicherhardware auf dem IceStick wirklich zu verwenden ist einiges an Erfahrung notwendig, die ein Anfänger wahrscheinlich nicht aufweißen kann. Diese Probleme traten während der Arbeit an dieser Studienarbeit auf und haben sehr viel Zeit gekostet. Letztendlich wurde auf ein anders Board mit anderer IDE umgestiegen.

Fazit zum IceStick mit Yosys: Die Verwendung ist für einen Anfänger zu kompliziert. Da kritische Fehler vom Werkzeug nicht automatisch erkannt werden, tappt ein Anfänger in die Falle Quellcode zu schreiben, der zwar synthetisiert, aber auf dem FPGA dann nicht funktioniert. Das erschwerte Erstellen von Speicher führt dazu, dass ein Anfänger daran scheitert einen RISC-V CPU einfach zu erstellen. Eine detailierte Einarbeitung in Yosys unter Aufsicht eines erfahrenen Mentors würde diese Situation wahrscheinlich entschärfen. Im Selbststudium steht diese Option allerdings nicht zur Wahl. Es wird Anfängern mit einem knappen Zeitrahmen nicht empfohlen mit Yosys zu beginnen.

# GOWIN Tang Nano 9K
Das Board an sich lässt sich für etwa 25 bis 60 Euro kaufen, je nachdem welches zubehör ausgewählt wird. Das Board ist damit vergleichsweiße günstig. Die IDE lässt sich einfach und kostenfrei herunterladen. Der Download der Education Version ist mit 413 MB vergleichsweiße klein und kann auf Microsoft Windows ausgeführt werden. 

Fazit: Es zeigt sich, dass die Arbeit mit dem GOWIN Tang Nano 9K Board am ehesten der Arbeit mit einem Arduino gleicht. Die IDE ist simpel und erste Verilog Module lassen sich schnell umsetzen und auf das Board laden. Die Synthese erfolgt sehr schnell, was die Wartezeiten gering hält. Dabei erkennt die Synthese viele relvante Fehler und gibt Warnungen und Fehler aus! Die IDE hat eine Bibliothek für IP-Cores, um z.B. einfach Speicher synthetisieren zu lassen. Es gibt einige gut dokumentierte Beispiele auf der Homepage des Produkts. Für einen Anfänger ist dieses Board gut geeignet, da er in der Lernphase sehr viele Fehler machen wird und die unkomplizierte und schnelle Deployment des Board damit einen großen Vorteil darstellt. Die beschrieben Designs lassen sich tatsächlich auf dem FPGA testen. Damit sinkt die Wahrscheinlichkeit sich mit Design und deren Simulation zu beschäftigen, die dann später nicht auf dem FPGA funktionieren.

# Digilent Arty S7

Das Arty S7 wird in unterschiedlichen Varianten angeboten. Hier wird die Variante XC7S25-1CSGA324 mit 23360 Logikelementen bewertet. Es handelt sich um die kleinste Ausführung des FPAG. Das Board hat genug Platz für einen simplen RISC-V CPU. Der Preis beläuft sich auf etwa 120 Euro und ist damit vergleichsweiße erschwinglich. Ein Vorteil des Boards ist seine Peripherie. Es werden viele PMOD Ports angeboten, es gibt Switch-Schalter, Push-Buttons und LEDs direkt auf dem Board. Zusätzlich besitzt das Board das Header-Layout eines Arduino. Damit lassen sich Arduino-Shields verwenden, wenn man die Spannugspegel berücksichtigt (Arduino-Systeme sind 5V Systeme während FPGAs normalerweiße weniger Spannung erwarten). Das Board ist nicht sehr groß und in der Verpackung sehr einfach zu transportieren. Strom wird ausschließlich durch die USB-Verbindung bereitgestellt. Das Board wird mit der Vivado IDE verwendet und programmiert. Hier wird auf jeden Fall sehr viel Festplatten Speicher benötigt. Es wird ein zwischenzeitlicher Speicherbedarf von 62,59 GB angegeben mit einen letztendlichen Speicherbedarf von 45,53 GB. Gemessen wurde vor der Installation 355 GB freier Speicher und nach der Installation 305 GB freier Speicher. Damit wurden 50 GB auf der Platte belegt. Im AMD Unified Installer wurde die Option "Vivado" und "Vivado ML Standard" ausgewählt, da es sich bei "Vivado ML Standard" um die kostenfrei Version der Software handelt. Zusätzlich werden die Pakete für die 7-Series ausgewählt, da auf dem Arty S7 ein Spartan 7 FPGA bestückt ist.

Die Vivaso IDE ist im Vergleich zur GOWIN IDE langsamer aber leistungsstärker. Sie erkennt ebenfalls viele Fehler und warnt damit den Benutzer bevor er Zeit verschwendet. Die Auswahl an IP-Blöcken ist sehr umfrangreich und deren Konfiguration wird durch eine Menüführung mit vielen Auswahloptionen unterstüzt.


Fazit:
Tang Nano 9K wird für schnelle Tests verwendet. Das System wird letzendlich auf dem Arty S7 integriert.



# 4. Erstellen des Assemblers

Um die korrekte Funktionsweiße des RISC-V CPU zu testen, muss ein Programm im Instruction-Memory des CPU abgelegt werden, damit der CPU diese Anweisungen ausführt. Die Daten, die im Hauptspeicher erwartet werden sind die Anweisung der Maschinensprache. Die Umwandlung von Assembler-Anweisungen in Maschinen Sprache wird Kodierung genannt. Ein Assembler hat die Aufgabe RISC-V Assembly Anweisungen zu Kodieren. Die RISC-V ISA definiert exakt, wie die Kodierung ablaufen muss. 

Die Instruktionen des RV32I Kerns sind in sechs Gruppern (RISBUJ). Einige Instruktionen verwenden Register (Register, R) andere enthalten Parameter aus Daten, die direkt in die Instruction einkodiert werden (Immediate, I). Andere Instruktionen sind für Verzweigungen auf Basis einer Bedingung (Branches, B) und Sprünge ohne Bedingung (Jumps, J) zuständig. Instruktionen die in den Speicher schreiben gehören der Store (S) Gruppe an. Die U Instruktionen werden verwendet um 32 bit Werte in Register zuladen, was sich mit einem 32 bit weiten Anweisungsformat gar nicht beschreiben lässt. U Instruktionen erlauben daher nur Immediate Wert aus 20 bit und füllen die fehlenden 12 bit implizit mit 0 auf.

Es wird ein Assembler in der Programmersprache Java erstellt. Dafür gibt es mehere Gründe. Java lässt sich (nach der Installation eines JRE oder JDK) auf jedem Bebtriebssystem ausführen. Die Assembler und Compiler aus der GNU toolchain sind nicht ohne weiteres auf Windows ausführbar. Ein weiters Argument ist, dass es ein Simples Tool ohne viele Parameter geben soll um Test-Programm schnell und einfach zu übersetzten. Echte Assembler sind komplizierter zu bedienen und verwenden immer auch ein spezifische Memory Layout für einen Target und fügen extra Instruktionen für den Target hinzu. Diese zusätzlichen Instruktionen werden von dem eigenen simplen CPU wahrscheinlich gar nicht unterstützt und das kodierte Programm kann dann nicht verwendet werden. Hier soll es lediglich um ein Assembler für einen sehr simplen RISC-V CPU gehen. Der Assembler kodierte die Anweisungen, bis auf leichte Optimierungen, so wie sie eingegeben worden sind. Es gibt einen Online Assembler unter https://riscvasm.lucasteske.dev/. Der Nachteil dieses Assembler ist es, dass er 64 bit RISCV Instruktionen für RV64I ausgibt ohne dass dies irgendwo auf der Seite erwähnt wird. Wenn man einen RISC-V CPU mit eine RV32I Kern erstellt, dann kann dieser Online-Assembler nur eingeschränkt verwendet werden.

An den Assembler ist eine Emulator angeschlossen, der das kodierte Programm direkt ausführen kann. Damit kann wird die Gültigkeit des Programms erst lokal verifiziert um zu verhindern, dass das Programm auf den CPU geladen wird obwohl es an sich fehlerhaft ist. Wenn man ein fehlerhaftes Programm auf dem CPU ausführt, dann kann man in der Entwicklungsphase nicht unterscheiden ob das fehlerhafte Verhalten von dem CPU oder von dem Programm stammt und es werden eventuell Fehler an Stellen gesucht, an denen es gar keine Fehler gibt. Dabei kann viel Zeit verloren werden wodurch diese Situation vermieden werden muss.

Der Assembler liest Dateien mit RISC-V Assembler Anweisungen ein:

```
__main:
loop_start:
    addi x5, x0, 0x0
    addi x6, x0, 0x0
    lui x7, 0
    addi x7, x7, 2

busy_loop_start:	
    beq x5, x7, 0xC             # if (x5 == x7) jump to loop_end (pc relative jump of +12 bytes)
    addi x5, x5, 1
    jal x0, busy_loop_start     # jal loop head (pc relative jump back -8 bytes)

busy_loop_end:
    lw x6, 52(x0)
    xori x6, x6, 1
    sw x6, 52(x0)

    jal x0, loop_start
```

Der Assembler benötigt das Label __main um den Haupteinsprungpunkt zu finden, damit er diese Adresse an den Emulator geben kann und der Emulator die Ausführung dort im Speicher beginnt. Für den RISC-V CPU auf dem FPGA sollte __main immer so gelegt werden, dass seine Adresse mit 0x00 zusammenfällt, also ganz am Anfang des Listing.

Die Assembler Instruktionen werden dann durch einen Parser basierend auf einer Grammatik für RISC-V Assembly geparst. Der Weg über das Parsing wurde gewählt, da RISC-V Assembly ganze Anweisungsbäume erlaubt. Ein Beispiel ist die Anweisung "jal   ra, pc - 176;" Diese Anweisungsbäume sind nur schwer durch einen manuel entwickelten Quellcode zu verarbeiten, der dann letztendlich über lange Zeit fehlerbehaftet sein wird. Auf lange Sicht macht der Einsatz einer Grammatik Sinn und spart Zeit.

Das Ergebnis des Parsing ist ein Parse-Tree. Ein Visitor wird über den Parse-Tree geführt. Der Visitor (RISCASMExtractingOutputListener) befüllt einzelne Instanzen der Klasse AsmLine mit den Werten, die er aus den RISC-V Assembler Zeilen ziehen kann. An dieser Stelle liegt jetzt die RISC-V Assembly Datei in Form einer Liste von AsmLine Objekten vor.

Der nächste Schritt ist das Anwenden einer ersten einfachen Optimierung. Wenn sich im Quellcode lui und addi Anweisungen befinden, kann ein Paar dieser Anweisungen durch eine LI (Load Immediate) Pseudo Instruktion ersetzt werden. Dies erscheint zunächst kontraproduktiv, da ein Assembler eher Pseudoinstruktionen auflösen als erstellen soll. Es ergibt nur dann Sinn, wenn man weiß, das zu einem späteren Zeitpunkt wieder Pseudoinstruktionen aufgelöst werden. Während der Auflösung hat der Assembler die Freiheit die LI Instruktion zu optimieren und es wird eventuel anstelle des lui, addi Paares nur ein lui ausgegeben. Durch dieses Verhalten korrigiert der Assembler eventuel unnötig eingefügt Instruktionen durch den Programmierer. Diese Optimierung wurde übernommen, da andere Assembler das gleicher Verhalten haben und sich die Ergebnisse des eigenen Assemblers nur mit anderen Assemblern gegenprüfen lassen, wenn man diese Optimierung auch anwendet.

TODO: Füge eventuell Beispiel einer Optimierung ein:

Im Folgenden erstellt der Assembler eine Tabelle von .equ Konstanten mit deren Werten, damit er Konstanten in Parametern, Expressions und Labeln durch numerische Werte ersetzen kann.

TODO Füge eventuel .equ Beispiel ein, das die Ersetzung zeigt.

Nach dem ersetzen der Konstanten werden Pseudo-Anweisungen aufgelöst. Beispielsweiße wird ein NOP Pseudo-Anweisung durch ein ADDI Befehl ersetzt, wobei die ADDI Operation keinen Effekt haben darf. Es wird eine ADDI Instruktion ausgegeben, die den Wert 0 auf das ZERO Register addiert! Dieser Ablauf ändert absolut nichts am Zustand der CPU außer, dass ein CPU Zyklus verbraucht wird und sich der Program Counter (PC) auf die folgende Anweisung verschiebt.

In diesem Abschnitt wurde zuvor erwähnt, dass LI Anweisung später aufgelöst werden. Dieser Zeitpunkt ist jetzt gekommen. Nachdem Auflösen der anderen Pseudo-Instruktionen wird nun auch LI aufgelöst. Dabei wird geprüft, ob die LI Anweisung ein Label als Immediate-Wert verwendet. Wenn ein Label verwendet wird, dann wird die Adresse des Labels ermittelt und die Differenz zwischen der aktuellen Adresse und der Label-Adresse gebildet. Wenn die Differenz mit einem simplen LUI geladen werden kann, dann wird nur ein LUI ausgegeben, ansonsten wird eine Kombination aus ADDI und LUI ausgegeben.

Jetzt wird der Call-Optimizer aufgerufen. Wenn eine Routine angesprungen wird, hat der Programmierer meherer Möglichkeiten den Sprung zur Routine zu implementieren. Wenn die Routine innerhalb eines Megabyte relative zur aktuellen Adresse zu finden ist (near call), dann reicht eine einzige JAL Instruktion. Wenn die Routine außerhalb des Megabyte zu finden ist (far call) dann wird eine Kombination aus AUIPC und JALR ausgegeben.

Nachdem alle Pseudo-Instruktionen durch echte Instruktionen ersetzt worden sind und alle Optimierer entschieden haben, ob sie ein oder zwei Instruktionen ausgeben möchten, liegt eine Liste mit ausschließlich "echten" Instruktionen vor. Auf dieser Liste werden jetzt relative Offsets ersetzt. Relative Offsets werden mit f und b und einem Label-Namen notiert. Der Assembler muss im Falle von f das erste folgende Label finden und im Falle von b das erste vorhergehende Label finden. Das gefundene Label wird dann durch seine Adresse ersetzt.

Siehe folgendes Beispiel von https://marz.utk.edu/my-courses/cosc230/book/example-risc-v-assembly-programs/ in dem 1f und 1b verwendet wird. 1 ist hier ein Label, dass doppelt verwendet wird, einmal in f-Richtung und einmal in b-Richtung.

```
.section .text
.global strlen
strlen:
    # a0 = const char *str
    li     t0, 0         # i = 0
1: # Start of for loop
    add    t1, t0, a0    # Add the byte offset for str[i]
    lb     t1, 0(t1)     # Dereference str[i]
    beqz   t1, 1f        # if str[i] == 0, break for loop
    addi   t0, t0, 1     # Add 1 to our iterator
    j      1b            # Jump back to condition (1 backwards)
1: # End of for loop
    mv     a0, t0        # Move t0 into a0 to return
    ret                  # Return back via the return address register
```

Im Anschluss werden Expression-Trees ausgerechnet und in die Instruktion eingesetzt. Danach werden die Modifier HI() und LO() ersetzt.

Der allerletzte Schritt ist es jetzt den Encoder auf jede AsmLine anzuwenden welcher MaschinenCode für die AsmLine ausgibt.

Damit hat der Assembler die Eingabe and en RISC-V CPU erzeugt.


# 5. Architektur des Pipelined RISC-V CPU

Das Design des RISC-V Multicycle CPU basiert auf dem Design aus dem Buch [111][Digital Design and RISC-V Computer Architecture von Harris & Harris]. Das Buch gibt einen RV32I Kern vor, der vollständig in Verilog und auch VHDL Code angegeben ist und nur eine Teilmenge der Befehle unterstützt. Der angegebene Code implementiert einen Single Cycle CPU, der keine Pipeline besitzt. Damit durchläuft er alle benötigten Phasen (Fetch, Decode, Execute, Memory Access und WriteBack) für jeden einzelnen Befehl bis ein einziger Befehl abgearbeitet ist, bevor er mit der nächsten Anweisung fortfährt.

In einer zweiten Ausbaustufe, wird die Architektur dann um einzelne Phasen erweitert. Für die zweite Stufe gibt es im Buch keinen Quellcode mehr. Das Buch beschreibt lediglich die Architektur und bespricht die Wirkungsweiße. Die letzte Ausbaustufe verwendet die einzelnen Phasen und erweitert den RISC-V CPU um eine Pipeline, die mehr als eine Anweisung gleichzeitig ausführt. Diese dritte Aufbaustufe wird ebenfalls nur beschrieben. Diese Studienarbeit implementiert diese Ausbaustufe in Verilog.

Die Phasen in einer Pipeline anzuordnen erlaubt es dem CPU jede Phase für einen anderen Befehl zu verwenden. Dies wird möglich, wenn man zusätzliche Hardware einfügt und damit Redundanzen schafft. Dies wird beispielsweiße für das ALU Modul gemacht, welches doppelt instantiiert wird. Durch redundante Hardware kann die Pipeline mehr als einen Befehl gleichzeitig bearbeiten.

Um alle benötigten Informationen durch die Pipeline zu führen, werden die Phasen der Pipeline durch sogenannte Pipeline Register getrennt.
Diese Pipeline Register erlauben es beispielweiße die dekodierten Parameter im Datenpfad oder die Steuersignale in der Kontrolllogik parallel zum Befehl durch die Pipeline zu führen, damit sie immer verfügbar sind.

## Design

Eine Übersicht über das Design wird in der Abbildung xyz gegeben:

TODO: Hier Bild 7.61 von Seite 453 aus [111] einfügen

Hier ist die Kontrolllogik und die HazardUnit am unteren Rand der Abbildung in blauer Farbe und der Datenpfad in der Mitte in schwarzer Farbe dargestellt.

### Datenpfad

Im Grunde besteht der Datenpfad aus der Hardware, die den CPU ausmachen. Es sind Speicher, SignExtender, Multiplexer und die redundante ALU enthalten. Der Datenpfad verarbeitet die Phasen der Pipeline in getakteter Form basierend auf dem Clock Signal. Ohne geeignete Steuersignale können die Multiplexer nicht entscheiden, welche Daten sie Auswählen und weitergeben. Ohne Steuersignale weiß die ALU auch nicht, welche Operation sie ausführen soll. Die Steuersignale stammen aus der Kontrolllogik.

### Kontrolllogik

Die Kontrolllogik besteht aus kombinatorischer Logik. Ihre Aufgabe besteht darin die Information so zu kombinieren, dass sie die korrekten Steuersignale für jeden Befehl and den Datenpfad weitergeben kann um den Befehl auszuführen. In diesem Sinne konfiguriert sich der Datenpfad dann ständig um, um dem aktuellen Befehl gerecht zu werden.

Die Kontrolllogik wird durch das Modul "controller" in der Datei controller.v implementiert. Die Eingabe-Ports entsprechen den dekodierten Fehler der aktuellen Instruktion nach der FETCH Phase. Die Ausgaben des Moduls entsprechen allen Linien, die aus der Kontrolllogik in den Datenpfad und die Hazard-Unit reichen.

Das Controller Modul enthält hauptsächlich die eingebettete Kontrolllogik des SingleCycle Designs. Des weiteren sind lediglich die notwendigen Pipeline Register enthalten um die Daten durch die Pipeline zu führen. Die SingleCycle Controlllogik besteht aus dem MainDecoder und dem AluDecoder. Der MainDecoder entnimmt der Instruction durch Dekodierung die Steuersignale für den Datenpfad. Der AluDecoder entnimmt der Instruktion die Operation, die die ALU ausführen muss.

Während der Entwicklung wurde zu Beginn ein schwerer Fehler begangen, der sehr viel Zeit gekostet hat. Das Buch [111] stellt beispielsweiße auf Seite 436 eine Zustandsmaschine für die Ausführung der Kontrolllogik dar. Hiervon inspiriert wurde die erste Version der Kontrolllogik als ebendiese Zustandsmaschine implementiert. Das Design hat teilweiße funktioniert und wurde daher in zeitraubender Feinstarbeit debugged und angepasst. Letztendlich lies sich die Funktion mit diesem Design nicht bewerkstelligen. Sich dieses Umstands bewusst zu werden ist für einen Anfänge ohne Erfahrung extrem schwer. Der Anfänger weiß nicht ob seine Programmierung fehlerhaft ist oder das verfolgte Konzept grundlegend nicht zum Erfolg führen kann.

Nach dem Ausschöpfen aller Ideen wurde die Idee der Zustandsmachine durch eine rein kombinatorische Implementierung der Kontrolllogik ohne jeglichen Zustand (bis auf die Pipeline Register) ersetzt. Diese Implementierung brachte den gewünschten Erfolg und die gewünschte Funktionalität und ist gleichzeitig um ein vielfaches kompakter als die Zustandsmaschine. Der Fehler lag im Verständnis der Aufgabe der Kontrolllogik. Die Kontrolllogik musse die Steuersignale kombinatorisch aufgrund der aktuellen Eingabe produzieren und hat darüberhinaus keinen Zustand.

Liegen die erzeugten Steuersignal einmal vor, werden sie in die PipelineRegister eingezetzt und bewegen sich ab dann parallel zur Instruktion durch die Pipeline bis der Befehl abgearbeitet ist.

### Data Hazards und die Hazard Unit

Eine Pipeline soll den Durchsatz eines CPU erhöhen indem Sie optimalerweiße vollumfänglich mehrere Befehle ausführt. Die Effizienz einer strikt entworfenen Piepline ist nicht immer 100 Prozent. Manchmal folgen Befehle aufeinander so dass die Informationen für den zweiten Befehl aus dem ersten kommen und nicht direkt verfügbar sind. Daher wird eine theoretisch strikte Pipeline angepasst um den Durchsatz auch bei ungünstigen Befehlsfolge zu erhöhen. Diese ungünstigen Situation werden Hazards genannt.

Es gibt unterschiedliche Arten von Hazards. Neben Hazards, die sich durch zustätzliche Hardware lösen lassen, gibt es Hazards, die lediglich durch einen Pipeline Stall beseitigt werden können. Die HazardUnit hat die Aufgabe Hazards zu erkennen und Steuersignale auszugeben, die die Pipeline in die Lage zu versetzen Befehle korrekt zu Ende zu führen, auch wenn ein Hazard vorliegt.

Die HazardUnit ist in hazard_unit.v implementiert. Data Hazards ergeben sich in folgender Befehlsfolge:

```
add s8, s4, s5
sub s2, s8, s3
```

Das Ergebnis der Addition steht erst nach der WriteBack Phase im Register s8, wird aber bereits in der folgenden Execute Phase von dort gelesen. Zur Lösung dieses Problems aktiviert die Hazard Unit ihr ForwardAE oder Forward BE Signal. Durch eine explizit hinzugefügte Leitung kann das Ergebnis einer Operation in direkt in der vorhergehenden Phase gemultiplext werden. Der Multiplexer wird dabei durch die Signale ForwardAE oder Forward gesteuert. Siehe Figure 7.55 auf Seite 447. Um die Verwendung der Register erkennen zu können werden der HazardUnit die Parameter aus dem Decoding des Befehls zugeführt. Hazards werden anhand einer logischen Bedingung beschrieben und lassen sich dadurch erkennen.

Es gibt Hazards, bei denen ein berechneter Wert aus der Zukunft abgeholt werden müsste um eine Berechnung durchzuführen. Da man nicht in die Zukunft reisen kann bleibt nur ein Ausweg: Es wird auf den Wert gewartet, den es noch nicht gibt. Warten in einer Pipeline wird Stall genannt. Jede Stage in der Pipeline hat einen Stall-Eingang bzw Enable-Eingang. Das Stall Steuersignal wird von der HazardUnit aufgrund einer logischen Bedingung berechnet. Wenn eine Pipeline Stage gestallt wird, als nicht enabled ist, führt sie einfach keine Aktion aus, behält aber ihren Zustand wie gehabt bei, so dass sie später fortfahren kann, wenn die benötigten Information vorliegen. Ein Beispiel das einen Stall auslöst ist

```
lw s7, 40(s5)
and s8, s7, t3
```

Der Wert aus dem Speicher ist zu dem Zeitpunkt an dem er mit t3 verunded werden soll noch gar nicht aus dem Speicher geladen worden. Der and-Befehl muss daher noch einen Clock-Zyklus warten, bis der Wert geladen ist. Die Execute-Stage muss bereinigt werden, während die Dekode Phase und die vorhergehende Fetch Phase beide gestallt werden müssen! Nun kann der and-Befehl aus der Dekode-Phase in die Execute-Phase übergehen, und der aus dem speicher geladene Wert wird der and-Anweisung zugeführt. Das löschen der Daten in der Execute-Phase ist notwendig, da sonst inkorrekte Daten durch die Pipeline laufen und falsche Ergebnisse liefern könnten.

Die letzte Gruppe der Hazards hinterlässt Überreste angefangener Befehle in Pipeline wobei diese angefangenen Befehle niemals zu Ende geführt werden dürfen. Die geschieht bei Branches, die Befehle überspringen. Ob ein Branch tatsächlich ausgeführt wird ist erst klar, wenn die folgenden Befehle bereits in die Phasen der Pipeline gelangt worden sind. Die Hazard Unit erkennt den Hazard indem sie das PCSrcE Signal überwacht, dass Branches aktiviert oder eben nicht. PCSrcE besteht aus einer eignen Logik in der Control-Logik. Das PCSrcE Signal wird er HazardUnit zugeführt. Um die Pipeline Stages zu löschen, gibt die HazardUnit Flush Signale an die Clear Eingänge der PipelineRegister aus. Damit führt ein Flush Kontrollsignal dazu das die Pipeline Register ihren Inhalt vergessen bzw. löschen. Durch das Löschen gelangen die halb abgearbeiteten Befehle nicht in die hinteren Phasen der Pipeline und führen damit keine Aktionen aus.

Der Code in dem HazardUnit Modul hat keinen Zustand und besteht lediglich aus logischen Kombinationen, die aus den Eingabesignalen die Steuersignale berechnen.






# 6. RISC-V Debug Spezifikation

Quellen: 
[100] https://five-embeddev.com/riscv-debug-spec/v0.13-release/core_debug.html
[101] https://riscv.org/wp-content/uploads/2024/12/riscv-debug-release.pdf

Die Interaktion mit einem Computer erfolgt über Ein- und Ausgabeperipherie. Dabei sind auf den Entwicklungsboards üblicherweiße Slider, Knöpfe, LEDs, Displays oder 7-Segment-Anzeigen vorhanden. Möchte man direkt über den Zustand des CPU oder der an den Systembus angeschlossen Module wie Speicher oder UARTs informiert werden, sind die Perihperie und simple Tests meist nicht detailiert genug.

Einen direkten Zugriff auf die Register und den Speicher erhält man über einen Debugger. Ein Debugger kann nur funktionieren, wenn die Zielhardware Funktionen bereitstellt, die der Debugger nutzen kann. Der Debugger muss über eine Infrastruktur mit dem CPU verbunden werden.

Der RISC-V Debug Support ist keine eigene Extension. Die Spezifikation für den Debug Support heißt "RISC-V External Debug Support" [101] und definiert alle Funktionen und wird im Folgenden Debug-Spezifikation genannt.

Um die Debug-Spezifikation zu verstehen ist es wichtig unterschiedliche Ebenen voneinander zu trennen, da ansonsten schnell Verwirrung entsteht. Die Ebenen, die zu trennen sind, sind die konkrete Implementierung der Infrastruktur (hier JTAG und Wishbone) und die Module die Spezifisch für RISC-V definiert worden sind (DTM, DMI, DM und Harts).

TODO: Hier Bild von Seite 6 der Debug_Spec darstellen.

Um den RISC-V Anteil zu beschreiben, beginnen wir auf dem Endbenutzergerät (PC oder Laptop), auf dem die Debugger-Software läuft. Im Zuge dieser Studienarbeit werden Python-Skripte erstellt, die die Aufgabe eines Debuggers übernehmen. Die Debugger-Software spricht mit einer Debug-Probe, welche die Signale auf das Entwickler-Board überträgt, auf dem das RISC-V System läuft. Die Debug-Spezifikation bezeichnet das RISC-V System als RISC-V Platform. Die RISC-V Debug Spezifikation gibt nicht vor, welche Technologie zur Übertragung der Signale verwendet werden muss. Dazu später mehr.

Innerhalb der RISC-V Platform wird die Verbindung zunächst am Debug Transport Module (DTM) terminiert. Es kann in einer RISC-V Platform mehrere DTM Implementierungen geben. Beispielsweiße könnte ein DTM über USB sprechen, eine andere Implementierung eines DTM über JTAG. An dieser Stelle bleibt die konkrete Implementierung noch abstrakt und spielt erstmal keine Rolle für die weitere Beschreibung der Debug-Spezifikation.

Der DTM verwendet das Debug-Module-Interface (DMI) um mit einem oder mehreren Debug-Modulen zu sprechen. Das Debug-Module-Interface sieht Register und Befehle im DTM vor, die eine Kommunikation mit dem DM auslösen. Diese Befehle sind definiert. Der Debugger muss diese Befehle schicken um bestimmte Aktionen innerhalb der RISC-V CPU auszulösen.

Die RISC-V CPU besteht aus mindestens einem Hart. Ein Hart besitzt Hardware um Instruktionen auszuführen (Eine Pipeline samt Registern und eine oder mehrere ALU). Fortschrittliche RISC-V CPUs können viel Harts enthalten um echtes Multithreading zu ermöglichen. Ein Debug-Module (DM) ist für einen oder mehrere Harts zuständig. Eine RISC-V Platform kann eine oder mehrer DM enthalten.

Der DTM muss im ersten Schritt die Anzahl der DMs ermitteln und dann DMs auswählen. Die momenten ausgewählten DMs erhalten dann Befehle vom DTM, die sie dann auf ihren Harts ausführen sollen. Mit diesen Befehlen kann ein DTM kann die DMs anweißen ihre Harts zu pausieren, zu reseten und weiterlaufen zu lassen. Es ist auch möglich die Register der Harts zu lesen zu schreiben und über den Systembus mit dem Speicher (RAM für Instruktionen und Daten) zu interagieren und den Speicherinhalt zu lesen und zu schreiben.

Die RISC-V Platform, die im Zuge dieser Arbeit erstellt wird, besitzt einen einzigen Hart um die Komplexität für Anfänger handhabbar zu gestalten. Aus dem gleichen Grund wird nicht jeder Teil der Debug-Spezifikation implementiert. Das Zählen und das Auswählen der DMs wird nicht implementiert. Es wird implizit von einem einzigen Hart ausgegangen der automatisch immer ausgewählt und damit immer das Ziel aller Befehle ist.

Die noch zu beschreibenden Teile sind die konkrete Implementierung zur Übertragung der Daten zwischen der Debug-Probe und dem DTM innerhalb der RISC-V Platform. Wie oben beschrieben, muss die Debugger-Software DMI-Befehle im DTM auslösen. Dazu muss sie diese DMI-Befehle übertragen. Innerhalb dieser Studienarbeit wird dazu JTAG verwendet.

JTAG ist ein Protokoll das zum Testen von Hardware eingesetzt wird. Es erlaubt neben dem Ausführen von Hardwaretestabläufen auch das Schreiben in Register und in den Speicher und wird daher auch häufig eingesetzt um Mikrokontroller-Firmware zu flashen. Innerhalb der JTAG-Beschreibung gibt es den TAP. Der TAP befindet sich im Zielsystem und terminiert dort die JTAG Verbindung. Da diese Aufgabe beinahe Deckungsgleich mit dem DTM aus der RISC-V Debug Spezifikation ist, wird ein JTAG TAP als RISC-V DTM ausgeführt oder alternativ wird ein TAP direkt mit dem DTM verbunden. 

JTAG ist in der Lage Register zu beschreiben. Die Interaktion zwischen dem JTAG Protokoll und dem RISC-V DTM besteht also darin, dass der JTAG-TAP in die Register des DTM schreibt. Die RISC-V Debug Spezifikation ist so ausgeführt, dass das Beschreiben eins Registers Aktionen direkt startet. Damit ist JTAG ein perfektes Protokol um die RISC-V Debug Spezifikation auszuführen.

Die RISC-V Platform ist jetzt also in der Lage DMI Befehle zu starten. Das Debug-Module-Interface (DMI) ist das Protokoll zwischen einem DTM und mehrern DMs. Die Frage ist, wie wird diese Datenübertragung in Hardware Implementiert? Die RISC-V Debug Spezifikation überlässt diese Detail der Implementierung und macht absolut keine Vorgaben. In der Debug-Spezifikation wird nirgends definiert, wie eine DMI Transaktion gestartet oder gestoppt wird. Der verwendet Wortlaut ist absichtlich abstrakt und es wird von Lesen und Schreiben gesprochen. Im Zuge dieser Studienarbeit wird die Interkation über den Wishbone Bus implementiert. Der Wishbone Bus ist gut dokumentiert (TODO: B4 Spec hier verlinken) und ohne Lizenzgebühren einsetzbar. Der Wishbone Bus ist von der Komplexität her minimal im Vergleich zu anderen Bussystemen (AMBA-Bus, AXI-Bus, ...).

Für einen einfachen Debugger sollen folgende Funktionen implementiert werden:
- Hart stoppen, reseten und starten und im Single Step modus ausführen sowie die normale Ausführung wieder anfnehmen.
- Register lesen schreiben
- Speicher lesen schreiben

Mit diesen Funktionen kann Maschinen code auf den RISC-V CPU geladen werden und das Programm kann im Single-Step Betrieb ausgeführt werden.

Um den Hart zu stoppen, hat der DM Kontroller über die Hardware Clock-Source, die den Hart mit einem Taktsignal verorgt. Wenn die Clock-Leitung unterbrochen wird, dann ist der Hart gestoppt. Zum Single-Step Betrieb generiert der DM ein eigenes Clock-Signal und führt dem Hart dieses Clock-Signal zu. Wenn der Hart fortgesetzt wird, dann wird die Hardware Clock-Source wieder zugeführt.

## JTAG State Machine

JTAG ist ein sehr allgemeines System. Die grundlegende Annahme die JTAG macht ist, dass jedes Gerät aus Registern besteht. JTAG definiert das Vorhandensein der Register IR (Instruction Register), BYPASS und mehrere Datenregister, über die jedes Gerät selbst entscheidet. Jedes Gerät sollte zumindest ein IDCODE Datenregister haben.

Um auf ein Datenregister zuzugreifen, wird der Instruction Code für dieses Datenregister in IR abgelegt. Damit wird das betreffende Datenregister aktiviert. Zu jedem Zeitpunkt kann nur ein einziges Datenregister aktiviert sein oder das BYPASS Register kann aktiviert sein. Das IR register ist parallel dazu immer aktiv es kann immer auf IR zugegriffen werden. JTAG schreibt vor, dass beim Start des Systems das IR Register so befüllt sein muss, dass das IDCODE Datenregister vorausgewählt wird.

Die Art und weiße, wie mit Registern interagiert wird ist verblüffend, wenn man sich zum ersten mal mit JTAG auseinander setzt. JTAG ermöglicht es mit lediglich vier Steuersignalen Register beliebiger Breite in einem Schreibzyklus zu schreiben. Dazu findet ein Umsetzung der seriellen Signale zur übertragung in eine Parallele Verarbeitung der Signale zum tatsächlichen Schreiben der Register statt. Es wird zunächst ein Shift-Register seriell befüllt und dann das Schrieben auf einen Schlag parallel ausgeführt. Die Serielle Befüllung dauert mehrere Zyklen. Das Beschreiben geschieht in einem einzigen Zyklus.

Es gibt ein Shift-Register für IR, ein Shift-Register für BYPASS und Shift-Register für die Datenregister. Wenn Datenregister gleiche Breite haben, können sich ein Shift-Register teilen. Datenregister mit spezieller Breite benötigen auch passender Shift-Register dieser Breite.

Zunächst definiert JTAG eine Zustandsmaschine aus 16 Zuständen. Die Zustandsmachine hat grundsätzlich zwei Arme. Ein Arm aktiviert das Shift-Register für IR und lädt Daten aus dem IR Register in das IR-Shift-Register. Daten können dann gleichzeitig aus dem IR Shift-Register ausgeschiftet und eingeschiftet werden. Der andere Arm führt die entsprechenden Funktionen für das aktuell ausgewählte Datenregister oder BYPASS Register aus.

TODO: Bild der StateMachine

Jedes JTAG Gerät muss intern diese JTAG Zustandsmaschine ausführen. Die Zustandsmaschine ist im JTAG TAP enthalten. Ein Gerät kann einen oder mehrere JTAG TAPs (Test Access Port) aufweißen. Mehrere Geräte mit jeweils mehreren TAPs können Teil einer JTAG Verbindung sein. In JTAG wird nicht über eine Punkt-zu-Punkt Architektur kommuniziert, es wird stattdessen eine Daisy-Chain aus JTAG TAPs gebildet. Durch diesen minimalistischen Ansatz ist das System über nur vier Signale steuerbar. 

TODO Bild der Daisy Chain aus Vivado

Dabei werden alle Shift-Register aller TAPS in einer langen Daisy-Chain aneinander gehängt! 

TODO: Bild Figure 2 von Medium einfügen. (https://medium.com/@aliaksandr.kavalchuk/diving-into-jtag-protocol-part-1-overview-fbdc428d3a16)

Alle bits werden von Anfang bis Ende durch diese Daisy Chain geschiftet und durchlaufen dabei alle Shift-Register aller TAPs! Das Bedeutet die Komponente, die mit der Daisy-Chain kommuniziert kann Daten lediglich an einen bestimmten TAP schicken, indem Sie Daten am Anfang der Daisy Chain einspeist und dann durch alle Register bis zum Ziel-TAP shifted. Eine weitere Besonderheit ist, das die Geräte in der Daisy-Chain keine Adressen haben sondern die Reihenfolge tatsächlich eine Rolle spielt. Es ist nicht möglich das ein Teil der Daisy-Chain Daten einfach bis zum Adressat durchreicht. Vielmehr werden Datenbits von links nach rechts geschiftet, bis sie im richtigen TAP landen.

Alle Zustandsmachinen in allen JTAG TAPs der DaisyChain befinden sich zu jedem Zeitpunkt im gleichen Zustand und führen synchron Transitionen aus. Um die synchronen Transaktionen zu ermöglichen sind die JTAG Steuersignale Test Clock (TCK) und Test Mode Select (TMS) parallel an alle JTAG TAPs angeschlossen. Das bedeutet, alle Zustandsmachinen haben den gleichen IR Registerinhalt und damit haben alle Maschinen das gleiche Shift-Register ausgewählt!

Die Steuersignal Test Data In (TDI) und Test Data Out (TDO) sind im Falle von TDO am Anfang der DaisyChain und im Falle von TDI am Ende der DaisyChain angeschloßen. Es ist damit möglich gleichzeitig ein Bit einzushiften (TDI) und dabei gleichzeitig ein Bit zu lesen, das in TDO ausgeschiftet worden ist.

TODO eventuell einfügen Bild Seite 29 von https://tu-dresden.de/ing/informatik/ti/vlsi/ressourcen/dateien/dateien_studium/dateien_lehstuhlseminar/vortraege_lehrstuhlseminar/hs_ws_0708/jtag-schnittstelle.pdf?lang=de

Mit JTAG ist es also möglich Werte in Register zu schreiben, zu warten und dann Werte aus Registern zu lesen. Oft werden Operationen in den Geräten angestoßen, sobald ein Register mit einem Wert beschrieben worden ist. Dabei wird ein bestimmter Wert in ein Shift-Register geschiftet. Wenn dann im Zustand UPDATE-DR der Wert aus dem Shift Register in das echte Datenregister zurückkopiert wird, findet die Ausführung der Operation statt.

Die RISC-V Debug Spezifikation definiert eine Reihe von Operationen, die durch das Schreiben bestimmter Register angestoßen werden.

## Implementierung in Verilog

Die JTAG Zustandsmachine ist in jtag_tap.v zu finden. Das Modul besitzt die Signale jtag_clk, jtag_tms, jtag_tdi und jtag_tdo. Ein Always-Block reagiert auf die negative Flanke der JTAG Clock und shifted ein Bit aus jtag_tdo aus. Ein anderer Always-Block regiert auf die positive Flanke der JTAG Clock und bestimmmt den nächsten Zustand der Statemachine. Dieser Block führt auch Aktionen aus, die für die jeweiligen Zustände ausgeführt werden sollen.

Wenn CAPTURE_DR betreten wird, wird abhängig vom IR Register das gewählte Datenregister in das entsprechende Shift-Register übertragen. Entsprechendes gilt wenn CAPTURE_IR betreten wird.

Im SHIFT_DR Zustand, wird abhängig vom IR Register das jeweilige Shift Register um eine position geshiftet. Das TDO bit wird für die folgende fallende Flanke gespeichert bevor TDI in das Register einfügt wird. Für SHIFT_IR gilt das gleiche.

Die Zustände EXIT1, EXIT2 und PAUSE sind weder für die Datenregister noch für die IR Register mit Aktionen belegt.

Im UPDATE_DR Register wird das Shift-Register in das Datenregister zurück kopiert. Dabei wird dieser Zeitpunkt auch verwendet um Aktionen anzustoßen. Beispielsweiße wird im Falle des DTM.dmi Register eine DMI Transaktion über den Wishbone Bus mit dem DM aktiviert. Dies ist der wichtigste Teil der Statemachine.



## RISCV Abstract Commands

Dieser Abschnitt beschreibt die Implementierung der Befehle, mit denen der Speicher gelesen und geschrieben werden kann. 

Die RISC-V Debug Spezifikation gibt an, das es mehrere Möglichkeiten gibt auf den Speicher zuzugreifen. Diese Möglichkeiten werden im Abschnitt B.2.7 Reading Memory aufgelistet. 

Die erste Möglichkeit ist es über den System-Bus direkt auf den Speicher zuzugreifen. Dazu definiert die Debug-Spezifikation eine Menge von Registern im DM. (Diese Register werden über das DTM.dmi Register über Wishbone geschrieben und gelesen.) Um Speicher zu lesen oder zu schreiben wird eine Kombination aus sbcs, sbaddress0 und sbdata0 verwendet. Der Speicherzugriff über den Systembus geht am System der Privilegien im RISC-V CPU vorbei und bietet vollen Zugriff auf den Speicher. Diese erste Option trifft implizit die Annahme, das der Speicher über ein Bussystem mit dem Hart verbunden ist. Das muss nicht immer der Fall sein.

Die zweite Möglichkeit ist es, den Program Buffer zu verwenden. Man lädt eine kleine Menge an RISC-V Maschinen Code in den Program Buffer, dessen Funktion das Lesen oder Schreiben des Speichers ist und führt den Hart auf dem Program Buffer aus, anstelle auf dem Instruction-Memory.

Eine dritte Möglichkeit sind abstrakte Commandos. Abstrakte Commandos werden sollen laut Debug Spezifikation mit den Privilegien des Harts ausgeführt werden, dabei muss aber nicht zwangsweiße der Hart selbst verwendet werden. Theoretisch könnte man diese Funktion also implementieren, indem man ein vorgefertigtes Programm in den Program Buffer lädt und den Hart ausführt. Alternativ sind andere Implememtierungen erlaubt.

In dieser Studienarbeit wird der dritte Ansatz ausgewählt. Dabei wird kein Program Buffer verwendet. Da der simple Hart keine Privilegien implementiert ist das System konform zur Debug Spezifikation, wenn der DM den Speicherzugriff einfach direkt selbst implementiert und ausführt. Es wird einfach direkt auf den Speicher zugegriffen. Dabei wird kein Bus zwischen DM und Speicher verwendet, da der simple RISC-V CPU keinen internen Bus besitzt.

TODO: beschreibe den Verilog-Code für den Speicherzugriff.

## Zusammenfassendes Beispiel

Das Schreiben in den Speicher über JTAG innerhalb der RISC-V Debug Spezifikation umfasst folgende Abfolge. Zunächst muss ein DMI Command abgesetzt werden, damit der DTM in den DM schreibt. Dazu wird der DMI Command in das DTM dmi register geschrieben. Der DMI Command ist ein Schreibbefehl in das Control Register des DM. Der Wert, der in das DM control Register geschrieben wird ist ein Abstract Command. Diese Abstract Command schreibt einen Wert in den Speicher. Der Wert der in den Speicher geschrieben wird, wird im Data0 register erwartet, die Adresse an die geschrieben wird, wird im Data1 Register erwartet. Streng genommen muss also vor dem Ausführen des Abstract Commands also zunächst Data0 und Data1 geschrieben werden. Wenn der Abstract Command ausgeführt worden ist, gibt es keinen Rückgabewert!

Das Lesen aus dem Speicher erfolgt ebenfalls über einen Abstract Command. Dieser startet ebenfalls dadurch, dass ein DMI Command, welcher einen Wert in das DM Command Register schreibt, in das DTM dmi Register geschrieben wird. Damit wird der DMI Command in den DM schreiben. Die Adresse von der gelesen werden soll, muss sich im Register Data1 befinden. Der aus dem Speicher gelesene Wert wird im Data0 Register zurückgegeben. Von dort kann er mit einem anderen Abstract Command abgefragt und an den Debugger über JTAG zurückgegeben werden.

## Debug Probe und Python Skripte

Es gibt JTAG DebugProbes wie z.B. den Segger J-Link, den Jtagulator oder den simpleren GoodFet. Da die Implementierung in dieser Studienarbeit keine volle JTAG Implementierung liefert, wird eine einfache Umsetzung über einen Arduino DUE erstellt. Der Arduino Due kommuniziert über UART mit einem PC auf dem Python Skripte ausgeführt werden und setzt auf der anderen Seite Kommandos in die vier Signale JTAG_TMS, JTAG_CLK, JTAG_DTI und JTAG_DTO um.

Anbei ein kleiner Auszug, der zeigt, wie der Arduino die Zustandsmachine antreibt, indem er das TMS eintaktet:

```
for (size_t i = 0; i < len; i++) {

    uint8_t bit = *in_data & 0x01;
    *in_data >>= 1;

    delay(delay_in_ms);
    digitalWrite(jtag_clk, LOW);
    jtag_clk_state = LOW;
      
    digitalWrite(jtag_tms, tms_data);
    digitalWrite(jtag_tdo, bit);

    delay(delay_in_ms); 
    digitalWrite(jtag_clk, HIGH);
    jtag_clk_state = HIGH;

    // cause negedge and read data
    delay(delay_in_ms);
    digitalWrite(jtag_clk, LOW);
    jtag_clk_state = LOW;

    delay(delay_in_ms);
    int val = digitalRead(jtag_tdi);
    *read_data >>= 1;
    *read_data |= (val << 7) << 24;
  }
}
```

Das Protokoll zwischen den Python Skripten und dem Arduino definiert ein einfaches Datenformat und lediglich drei Kommandos. Das Ping Kommand wird mit einem Pong beantwortet und dient lediglich zum Test ob der Arduino antwortet. Der SEND_TMS Kommand kann verwendet werden um die StateMachines anzutreibem ohne Daten über TDI zu schicken. Das letzte Kommando ist SHIFT_DATA. Hier wird eine Menge an Bits über TDI in alle StateMachines geschiftet. Dabei kann angegeben werden, welches Signal an TMS angelegt werden soll. Dies it notwendig um ein Register bis auf das letzte Bit zu füllen und dann zusammen mit dem letzten Bit auch ein TMS Signal zu schicken, mit dem die StateMachine dann angewießen wird den Shift-Zustand zu verlassen, so dass das Register "versiegelt" wird und keine falschen Daten mehr in das Register gelangen! Register werden nämlich nur während des Shift Zustandes mit Daten aus TDI versorgt.

Innerhalb der Python Skripte wird mit der ZustandMaschine umgegangen um bestimmte Register auszuwählen und Daten in diese Register zu shiften. Damit lassen sich die Abfolgen für abstrakte Kommmandos ausführen.

# Abschluss und Ausblick.

Es wurde Hardware und Software verglichen, bewertet und ausgewählt um einen einfachen RISC-V Kern mit einer Pipeline zu implementieren. Das Design wurde beschrieben. Das RISC-V Systems wurde um eine Programmierschnittstelle per JTAG unter verwendeung der RISC-V Debug-Spezifikation erweitert. Damit ist das System um eigene Software erweiterbar. Die Software kann durch einen eigens erstellten Assembler für 32-Bit RISC-V übersetzt und durch einen eigens entwickelten Emulator vorgeprüft werden. 

Damit ist das Ziel einen Studenten eine Weg zur Implementierung eines RICS-V Systems aufzuzeigen erreicht.

Es gibt Teile der Implementierung die vervollständigt werden können. Es sind nicht alle RV32I Befehle im Kern ausführbar. Mehrere interessante Extensions könnten hinzugefügt werden wie beispielsweiße Komprimierte Befehle oder Fließkommaarithmetik. Ein Systembus mit MemoryMapped Peripherie könnte hinzugefügt werden. Damit wird der RISC-V Hart immer mehr zu einem Mikrocontroller Design und kann mit externen Hardwarebausteinen kommunizieren.

Die Übertragung der JTAG Befehle über den Arduino ist funktionsfähig allerdings momemtan sehr langsam getaktet, da die Always-Blöcke, die im FPGA auf die JTAG Clock reagieren oft Bits verpassen oder duplizieren, wenn der Takt angehoben wird. Das ist unverständlich, da die Verbindung langsamer aus ein UART mit Baudrate 115200 ist und damit eigentlich noch einfach für einen FPGA handhabbar sein sollte. An dieser Stelle kann das Verfahren mit echter JTAG Hardware nachgeprüft und die Übertragungsrate angehoben werden. Momentan wurde lediglich die Machbarkeit gezeigt.

Dies ist der Anfang der FPGA Entwicklung. Es ist sehr viel Erfahrung notwendig um funktionierende Systeme zu bauen. Ein Anfänger kann richtig oft nicht von falsch unterscheiden und muss durch Fehler lernen. Die kommenden Schritte werden sein aus anderen Design zu lernen und so viele Bücher über Verilog und VHDL zu lesen wie möglich.

## Danksagung

Ich bedanke mich sehr herzlich bei Dr. Christian Jakon für die Betreeung der Arbeit und seine Hilfestellung und Ratschläge beim Erstellen dieser Arbeit. FPGAs haben einen sehr hohen Stellenwert für mich und das Erstellen dieser Arbeit bringt mich meinem Ziel sehr viel näher. Nebenbei gesagt, hat die Arbeit mit dem RISC-V System und dem FPGA auch sehr viel Spaß gemacht. In einer Umgebung die aus kleinsten Bausteinen besteht kann mit Kreativität eine vielzahl an Lösungen erstellt werden, auch wenn der Weg zur Lösung oft ein steiniger ist.



