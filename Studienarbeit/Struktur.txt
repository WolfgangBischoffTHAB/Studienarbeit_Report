20 Seiten

# Titel

Implementierung eines RISC-V CPU mit Teilen aus dem RISC-V External Debug Support

# Zielsetzung

Das Ziel dieser Studienarbeit ist es einen einfachen RISC-V CPU zu erstellen. Das Testen des CPU durch selbstentwickelte Software und das Debuggen der Software auf dem CPU ist ebenfalls Teil der gesetzten Aufgabe. Dazu soll nicht nur ein RISC-V CPU entwickelt werden, sondern es sollen auch Tools bereitgestellt werden, mit denen sich die obigen Aufgaben ausführen lassen. Die FPGA Entwicklungswerkzeuge werden vorgestellt, bewertet und schließlich ausgewählt.

# Herausforderungen

Die Implementierung eines RISC-V CPU stellt einen Student bzw. Anfänger vor mehrere handfeste Herausforderungen.

1. Auswahl der Hardware - Ein FPGA Entwicklungsboard kann von der Bildungseinrichtung beigestellt werden und die Auswahl ist damit vorgegeben. Es kann trotzdem sinnvoll sein sich nochmals über die Wahl des Entwicklungsboards gedanken zu machen, da die Auswahl des Entwicklungsboards Einfluss auf die zu verwendende FPGA-Entwicklungstools hat. Die Verwendung bestimmter FPGA-Entwicklungstools haben selbst wiederum Konsequenzen und die Auswahl sollte auf einem sinnvollen Wissensstand erfolgen. Ein weiterer Punkt ist der Preis und die Verfügbarkeit der FPGA Boards. Es gibt Boards zu bereits niedrigen Kosten, die sich für das Erlernen der FPGA-Entwicklung sehr gut eignen und aufgrund ihrer Softwaretools sogar bestimmte Vorteile gegenüber sehr kostspieligen Boards haben.
-> Die Lösung in dieser Studienarbeit wird es sein, die Integration auf einem professionellen Board (Arty S7) ausgeführt, während schnelle Tests auf einem GOWIN Tang Nano 9k erfolgen.

2. Auswahl der FPGA-Entwicklungstools - Die FPGA Entwicklungstools können vom Hersteller des FPGA gestellt werden. Diese Herstellertools sind im Falle von Vivado (Vom Hersteller AMD für Artix, Kintex, Virtex, Spartan und Zynq 7000 series und auch UltraScale and UltraScale+ Familien) und Quartus Prime (Intel für Cyclone und MAX chips) sehr umfangreich. Vorteile von Intel und AMD sind die Bereitstellung von IP-Bibliotheken und Generatoren. Nachteile sind die schiere Größe dieser Tools (mehrer zig GB an Festplatten für die Installation sind keine Seltenheit). Ein mittleres Angebot wird von kleineren Herstellern wie der Firma Lattice und der Firma GOWIN gemacht. Ihre FPGAs sind teilweiße zusätzlich auch durch OpenSource Toolchains abgedeckt aber die Herstellereignenen FPGA-Entwicklungstools sind auch eine gute Option und bieten oft einen guten Funktionsumfang bei kleinerem Resourcenverbrauch. Des weiteren geht die Bandbreite bis hin zu OpenSource Tools (Yosys, NextPNR) am unteren Ende des Resourcenverbrauchs aber leider oft auch der Funktionalität. Die Toolchains werden in einem späteren Abschnitt miteinander verglichen und eine Auswahl wird getroffen.
-> Die Lösung wird es sein, Vivado für das Endprodukt und die GOWIN FPGA Designer Software für schnelle Tests verwendet wird.

3. Erlernen der HDLs Verilog, System Verilog oder VHDL. Ausführen von Simulationen und übertragen der Designs auf den FPGA und dortigem Test. Es kann sein, dass Designs trotz funktionierender Simulation nicht auf dem FPGA funktionieren. Die Fehlersuche ist dann sehr schwer, da es keine "Debugger" für FPGAs und deren internen Abläufe gibt. Im schlimmsten Fall kann das Design überhaupt kein Lebenssignal von sich geben, obwohl es in der Simulation korrekt Signale ausgegeben hat. Von Vorteil ist es, wenn die Dauer eines Zyklus von der Änderung des Designs über die Synthese bis zum Upload des Bitstreams kurz sind. Das Verständnis vom Design Digitaler Systeme, also Signale (wires) und getackteter, Zustandsbehafteter Logik (Register mit Clock-Flanken) ist ein Erfahrungswert, den ein Anfänger nicht intuitiv besitzt. Die Fähigkeit ein digitales System zu erstellen weicht von der Fähigkeit in einer Programmiersprache oder Assembler zu programmieren ab. Das digitale System muss in den meisten Fällen als Gesamtkonstrukt betrachtet werden muss, während ein Computerprogramm in einzelne Anweisungsfolgen aufteilbar ist. Der FPGA Entwickler muss einen großen Kontext gleichzeitig in seinem Denkprozess berücksichtigen, während der Anwendungsprogrammierer nach Möglichkeit das "Teile und Herrsche" Prinzip anwenden kann. Ohne Erfahrung verliert sich ein Anfänger in der Komplexität und kann nicht mehr entscheiden woher ein Fehlverhalten kommt. 
-> Die Lösung für dieses Problem ist es sich an das Lehrbuch von Harris & Harris zu halten.

Auch nachdem die Aufgabe des Designs eines CPU gemeistert ist, gibt es weitere Herausforderungen.

4. Auswahl eines Assemblers - Es gibt wenige Assembler, die RISC-V Code in Maschinenbefehle übersetzen und dabei möglichst wenige Annahmen treffen.
Das Problem liegt in einer Diskrepanz zwischen der RISC-V Spezifikation und Lehrbüchern zu RISC-V und den Compilern und Assemblern, die tatsächlich zur Erstellung von Software genutzt werden. Die RISC-V Spezifikation und Lehrbücher sprechen über RISC-V Instruktionen und deren Kodierung in Maschinenbefehle ohne dabei ein konkretes Betriebssystem als Zielumgebung zu adressieren. Wirkliche Compiler haben die Aufgabe Maschinencode auszugeben, der konkrete Speicherbereiche belegt und die Kombination von unterschiedlichen Objektdateien in ein kombiniertes Programm ermöglicht. Für einen Anfänger kann diese Diskrepanz zu einer zusätzlichen Herausforderung werden, für die er nicht die notwendige Zeit oder Motivation hat. Ein echter Compiler benötigt beispielsweiße noch ein Linkerscript bevor er arbeitet. Das Produkt verwendet spezielle Quellcode-Abschnitte, die bestimmte Datenstrukturen initialisieren. Wenn man eine RISC-V CPU entwirft, möchte man eventuell lediglich simple Testprogramme von Adresse 0x00 ausführen und legt keinen Wert auf Adressbereiche oder Initialisierung bestimmter Daten. 
-> Die Lösung für dieses Problem wird es sein einen Assembler für 32-bit RISC-V bereitzustellen, mit dem schnell, unkompliziert und ohne Annahmen RISC-V Assemblercode in Maschinenbefehle für den Upload in den CPU übersetzt werden kann. Der erstellte Maschinen-Code führt das Assembler-Programm dann exakt aus, ohne jegliche Änderungen oder Annahmen für ein Zielsystem zu treffen.

5. Interaktion mit dem CPU - Wenn das Design über den Bitstream auf den FPGA bereitgestellt worden ist, wird der CPU ein Programm ausführen. Die Frage ist, wie man jetzt mit dem CPU interagiert. Diese Thema wird in den Lehrbüchern zu digitalem Design nicht adressiert. Das Ziel ist es nicht Peripherie wie Druckknöpfe, LEDs oder LCDs an den CPU anschließen, sondern mit dem CPU selbst zu kommunizieren. Nach Möglichkeit soll der CPU gestoppt und gestartet werden können. Der Zugriff auf Register und den Speicher soll möglich sein. Dazu gibt es die Debug-Spezifikation für RISC-V (TODO: Referenz auf eine bestimmte Version der Debug-Spezifikation hier einfügen! file:///C:/Users/lapto/dev/fpga/gowin_tang_nano/riscv_debug/doc/riscv-debug-release.pdf). Die Debug-Spezifikation beschreibt Komponenten um mit den Harts eines RISC-V CPU zu interagieren. Im RISC-V Umfeld wird eine Recheneinheit als Hart bezeichnet. Ein Hart führt einen Thread aus. Ein CPU kann beliebig viele Harts enthalten. Die Kommunikation kann über das JTAG-Protokoll ausgeführt werden. 
-> Die Lösung in dieser Studienarbeit wird es sein einen Teil der RISC-V Debug Spezifikation implementiert, gerade genug um die oben geforderten Punkte über eine JTAG DebugProbe auszuführen. Die DebugProbe wird auf einem Arduino DUE ausgeführt, der direkt mit dem FPGA Entwicklungsboard verbunden ist.

# 0. Einleitung zu RISC-V

RISC-V ist eine Instruction Set Architecture (ISA). Ein Instructionset Architecture ist eine Menge an Anweisungen, Registern und Datentypen. Damit beschreibt RISC-V keine konkrete CPU Architektur sondern gibt Befehle und Register vor, die auf einer konkreten Architektur ausführbar und vorhanden sein müssen, damit dieses System RISC-V konform ist und RISC-V Befehle ausführen kann. Laut der RISC-V homepage (Quelle: https://riscv.org > about > faq > Who uses an ISA?) ist eine ISA auch im Zuge der Leere einsetzbar damit Studenten die Wirkungsweiße eines Computers verstehen lernen. RISC-V wurde daher auch vor dem Hintergrund der Lehre erstellt.

Damit steht RISC-V in Konkurrenz mit der x86 ISA (Chips von Intel, AMD und weiteren), der ARM ISA (Chips von STM32, Renesas, NXP, Qualcomm und andere) und allen anderen definierten Instructionsets (AVR, Itanium (IA-64), MIPS, Z-80 und viele weitere). Die Besonderheit von RISC-V ist das Lizenzmodel. Das Lizenzmodel besteht aus der Erlaubnis zur freien Benutzung und damit der Abwesenheit jeglicher Lizenzkosten (Quelle: https://riscv.org/about/faq/#:~:text=There%20is%20no%20fee%20to%20use%20the%20RISC%2DV%20ISA. In Google eingeben: https://riscv.org > about > faq > What is the license model ).

RISC-V ist an der Universität UC Berkeley entwickelt worden. Dabei ist RISC-V aus dem Wissenschatz erstellt worden, den die Beteiligten im Zuge der vier Vorgängeprojekte (RISC-I bis RISC-IV) sammeln konnten und heißt damit sinnigerweiße RISC-V (Quelle: https://riscv.org > about > faq > Why is it called RISC-V).

RISC-V hat in den letzten Jahren weitere Fortschritte gemacht. Das Tripple-A Spiel "The Witcher 3" lässt sich mit Einschränkungen auf einem RISC-V System (https://milkv.io/pioneer) ausführen. RISC-V Mainline Support wurde Linux im Jahre 2022 hinzugefügt. Die 64 Bit Variante von RISC-V hielt im Jahre 2023 Einzug in den Linux-Kernel (Quelle: https://en.wikipedia.org/wiki/RISC-V)

Die RISC-V ISA ist keine monolithische Spezifikation. Das angewandte Prinzip ist, dass ein Kern von Funktionen für eine gewisse Bit-Breite (XLEN) vorhanden sein muss, der dann durch Extensions erweitert werden kann. Beispiele für Kerne sind RV32I, RV64I und RV128I die Integer-Operationen mit jeweiligen Registerbreiten von 32, 64 und 128 Bit unterstützen. Extensions fügen dem System Floating-Point Unterstützung, komprimierte Anweisungen, Vector-Mathematik, Kryptografie, Atomic-Operationen und viele weitere Funktionen hinzu.

In dieser Studienarbeit wird ein Teil des Kerns RV32I umgesetzt. Dieser Umfang kann durch weitere Entwicklungstätigkeit immer weiter bis zum vollem Umfang von RV32I ergänzt werden wenn notwendig. Des weiteren wird ein Teil des RISC-V External Debug Support hinzugefügt.

# 1. Auswahl der Hardware

Als Optionen für Entwicklungsboards betrachten wir

- Lattice iCEstick
- GOWIN TangNano 9k
- Digilent ARTY S7

Kriterien: 
 - Größe des FPGA - Gewichtungsfaktor(3) - Passt ein RISC-V Design auf den FPGA?
 - Formfaktor - Gewichtungsfaktor(1) - (passt es auf den Tisch, kann man es leicht in einem Rucksack mitnehmen z.B. zwischen Hochschule und Wohnung)
 - Peripherie - Gewichtungsfaktor(3) - Wieviel Peripherie hat es (PMODs, LEDs, Breakout Pins, ...).
 - Anschaffungskosten - Gewichtungsfaktor(1) - Sind die Anschaffungskosten für den Anwendungszweck gerechtfertigt. 
 - Freie Software - Gewichtungsfaktor(5) - Lässt sich der FPGA überhaupt mit Herstellersoftware programmieren

# 2. Auswahl der FPGA-Entwicklungstools

Kriterien zur Bewertung von FPGA Entwicklungstools

- Installationsplattenplatz - Gewichtungsfaktor(2) - (100-te GB sind schlecht!)
- Geschwindigkeit der Synthese - Gewichtungsfaktor(1) - (allgemeine Performance des Tools)
- Fehlererkennung der Synthese - Gewichtungsfaktor(5) - (logische Loops werden von Yosys nicht erkannt! Vom professionellen Tool schon)
- Editorqualität - Gewichtungsfaktor(1) - (go to definition, highlight von gehovertem Symbol, ...)

Da diese Studienarbeit Lösungen für den Student in einem der unteren Semester sucht, muss davon ausgegangen werden, dass dieser Student keine High-End Hardware zur Verfügung hat um erste Tests mit Hardwarebeschreibungssprachen zu machen und auch nicht bereit oder in der finanziellen Situation ist um sich High-End Hardware zu kaufen. Das wahrscheinlichste Szenario ist, dass die Hardware ein Laptop mittlerer Leistungsklasse mit einem Windows-Betriebssystem ist. Im folgenden werden die Messungen auf einem AMD Ryzen 7 PRO 4750U mit 32GB RAM ausgeführt. Die acht Kerne (16 Threads) haben einen Basistakt von 1,7 GHz und einen Boosttakt von 4,1 GHz. Der Prozessor besitzt 512 KB L1 Cache, 4 MB L2 Cache und 8 MB L3 Cache. Das System stamt aus dem Jahr 2020. Die Messungen werden unter Windows 11 Pro, 24H2 (OS build 26100.4349) ausgeführt. Bezüglich der Festplattenkapazität ist mit 250 GB zu rechnen, von denen wahrscheinlich in der Realität nicht mehr viel Platz übrig ist. In dieser Arbeit wird daher auch Augenmerk auf den benötigten Speicherbedarf der Tools gelegt.

Im Zuge dieser Studientarbeit wurden die FPGA Entwicklungsboards Lattice iCEstick, GOWIN Tang Nano 9K und Digilent Arty S7 getestet.

# Lattice iCEstick (https://www.latticesemi.com/icestick)
Der iCEstick der Firma Lattice ist ein FPGA im USB-Stick Format. Damit nimmt er kaum Platz auf dem Schreibtisch ein und kann leicht transportiert werden. Der Anschaffungspreis liegt bei etwa 130-150 Euro. Damit ist der Lattice iCEstick vergleichsweiße teuer. Die Peripherie weißt leider nur wenige Breakout Pins auf, dafür besitzt das Board aber einen PMOD Header und 5 LEDs, sowie einen Infrarot IrDA Sensor. Der iCEstick besitzt einen Lattice iCE40HX-1k FPGA chip (https://www.mouser.de/ProductDetail/Lattice/iCE40HX1K-TQ144?qs=F9A14TELRMtiYSwGl6R%2Fcw%3D%3D&srsltid=AfmBOopRdilmfbmh3HyTAYo1qr89NC4w5Ca6M5ykeBUMYd6rbPP2OnCq). Auf dem FPGA hat ein kleiner RISC-V CPU Platz (siehe https://github.com/BrunoLevy/learn-fpga und das FemotRV Projekt). Die offizielle IDE ist iCEcube2 und kann auf Microsoft Windows ausgeführt werden. Der Download von iCEcube2 ist 700MB groß und zur Installtion werden 880MB benötigt. Damit ist das Softwarepacket insgesamt vergleichsweiße klein. Zum Programmieren des Bitstream wird die Diamond Programmer Software verwendet, der den Bitsream in das OnBoard SPI Flash schreibt. Die iCEcube2 Software benötigt einen Lizenz zur Ausführung. Die Lizenz wird auf Anfrage an nicht-kommerzielle Entwickler und Start-Ups ausgegegben, falls Lattice die Anfrage nach einer Lizenz genemigt. Normalerweiße kostet diese Lizenz Geld. 

Als Alternative zur Software des Herstellers wurde die OpenSource Toolchain Yosys (https://github.com/YosysHQ/yosys) verwendet. Yosys kann in einer für Windows vorgefertigten Version von https://yosyshq.net/yosys/download.html heruntergeladen werden. Yosys ist ein Sammlung an Kommandozeilentools um Verilog zu synthetisieren, eine Bitstream zu erzeugen und den Bitstream auf die unterstützten FPGAs zu laden. Vorteile von Yosys sind der schnelle und unkomplizierte Download, der mit 303 MB sehr kompakt ist. Ein weiterer Vorteil ist die relativ schnelle Synthese-Zeit. Die Nachteile von Yosys sind die mangelhafte Erkennung und Ausgabe kritischer Fehler und die fehlende Option IPs einzusetzen. Der Nachteil ohne IP ist, dass ein Speicherblock vom Tool als Speicher erkannt werden muss. Diese Erkennung führt das Tool implizit automatisch aus und der Benutzer muss hoffen, dass sein Design als Speicher erkannt wird. Es gibt vorgegebene Verilog Designs, die Yosys als Speicher erkennen soll. Nicht immer funktioniert die Erkennung automatisch. Wenn ein Speicher vom Synthese-Tool nicht als Speicher IP erkannt wird, das Design nicht durch Hardware im FPGA implementiert werden. Wenn diese Situation eintritt, synthetisiert Yosys Speicher durch Logikblöcke und belegt damit direkt große Mengen an Resourcen auf dem FPGA, die dann nicht mehr für echte Logik zur Verfügung stehen! Um die Speicherhardware auf dem iCEstick wirklich zu verwenden ist einiges an Erfahrung notwendig, die ein Anfänger wahrscheinlich nicht aufweißen kann. Diese Probleme traten während der Arbeit an dieser Studienarbeit auf und haben sehr viel Zeit gekostet. Letztendlich war dies neben der mangelnden Fehlererkennung einer der Hauptgründe warum der iCEstick zur Entwicklung ausschied.

Fazit zum iCEstick mit Yosys: Die Verwendung ist für einen Anfänger zu kompliziert. Da kritische Fehler vom Werkzeug nicht automatisch erkannt werden tappt ein Anfänger zu leicht in die Falle Quellcode zu schreiben, der zwar synthetisiert wird dann aber auf dem FPGA dann nicht funktioniert. Das erschwerte Erstellen von Speicher führt dazu, dass ein Anfänger daran scheitert einen RISC-V CPU einfach zu Erstellen, der auf den iCEstick passt. Eine detailierte Einarbeitung in Yosys unter würde diese Situation wahrscheinlich entschärfen. Im Fernstudium steht diese Option allerdings nicht zur Wahl. Es wird Anfängern mit einem knappen Zeitrahmen nicht empfohlen mit Yosys zu beginnen.

# GOWIN Tang Nano 9K

Das Board an sich lässt sich für etwa 25 bis 60 Euro kaufen, je nachdem welches Zubehör ausgewählt wird. Das Board ist damit vergleichsweiße günstig. Die IDE lässt sich einfach und kostenfrei herunterladen. Der Download der Education Version ist mit 413 MB vergleichsweiße klein und kann auf Microsoft Windows ausgeführt werden. 

Fazit: Es zeigt sich, dass die Arbeit mit dem GOWIN Tang Nano 9K Board am ehesten der Arbeit mit einem Arduino gleicht. Die IDE ist simpel und erste Verilog Module lassen sich schnell umsetzen und auf das Board laden. Die Synthese erfolgt sehr schnell, was die Wartezeiten gering hält. Dabei erkennt die Synthese viele relvante Fehler und gibt Warnungen und Fehler aus! Die IDE hat eine Bibliothek für IP-Cores, um z.B. einfach Speicher synthetisieren zu lassen. Es gibt einige gut dokumentierte Beispiele auf der Homepage des Produkts. Für einen Anfänger ist dieses Board gut geeignet, da er in der Lernphase sehr viele Fehler machen wird und das unkomplizierte und schnelle Deployment auf dem Tang Nano 9k damit einen großen Vorteil bietet. Die beschriebenen Designs lassen sich oft auf dem FPGA testen ohne das die Wartezeit zermürmbend wirkt. Damit sinkt die Wahrscheinlichkeit sich mit Designs und deren Simulation zu beschäftigen, die dann später nicht auf dem FPGA funktionieren.

# Digilent Arty S7

Das Arty S7 wird in unterschiedlichen Varianten angeboten. Hier wird die Variante XC7S25-1CSGA324 mit 23360 Logikelementen bewertet. Es handelt sich um die kleinste Ausführung des FPGA. Das Board hat genug Platz für einen simplen RISC-V CPU. Der Preis beläuft sich auf etwa 120 Euro und ist damit vergleichsweiße erschwinglich. Ein Vorteil des Boards ist seine Peripherie. Es werden viele PMOD Ports angeboten, es gibt Switch-Schalter, Push-Buttons und LEDs direkt auf dem Board. Zusätzlich besitzt das Board das Header-Layout eines Arduino. Damit lassen sich Arduino-Shields verwenden, wenn man die Spannungspegel berücksichtigt (Arduino-Systeme sind 5V Systeme während FPGAs normalerweiße weniger Spannung erwarten). Das Board ist nicht sehr groß und in der Verpackung sehr einfach zu transportieren. Strom wird ausschließlich durch die USB-Verbindung bereitgestellt. Das Board wird mit der Vivado IDE verwendet und programmiert. Hier wird auf jeden Fall sehr viel Festplattenspeicher benötigt. Es wird ein zwischenzeitlicher Speicherbedarf von 62,59 GB angegeben mit einen letztendlichen Speicherbedarf von 45,53 GB. Gemessen wurde vor der Installation 355 GB freier Speicher und nach der Installation 305 GB freier Speicher. Damit wurden 50 GB auf der Platte belegt. Im AMD Unified Installer wurde die Option "Vivado" und "Vivado ML Standard" ausgewählt, da es sich bei "Vivado ML Standard" um die kostenfrei Version der Software handelt. Zusätzlich werden die Pakete für die 7-Series ausgewählt, da auf dem Arty S7 ein Spartan 7 FPGA bestückt ist.

Die Vivado IDE ist im Vergleich zur GOWIN IDE langsamer hat dafür aber einen größeren Funktionsumfang. Sie erkennt bereits bei der Synthese viele Fehler und warnt damit den Benutzer bevor er Zeit verschwendet. Die Auswahl an IP-Blöcken ist sehr umfrangreich und deren Konfiguration wird durch eine Menüführung mit vielen Auswahloptionen unterstüzt. Speicherlassen sich damit sehr einfach erstellen und werden im Design dann durch wirkliche Hardware im FPGA und nicht durch Logikblöcke ausgeführt.

Vergleichstabelle

-- = 1
- = 2
0 = 3
+ = 4
++ = 5

| Größe des FPGA |
| -------------- |
| --             |
| -              |
| 0              |

| Board und IDE                     | Formfaktor | Perihperie | Anschaffungskosten | Freie Software vom Hersteller | Festplattenplatz |
| --------------------------------- | ---------- | ---------- | ------------------ | ----------------------------- | ---------------- |
| Lattice iCEstick & Yosys          | ++         | -          | 0                  | --                            | ++               |
| GOWIN TangNano 9k & FPGA Designer | ++         | 0          | ++                 | +                             | ++               |
| Digilent ARTY S7 & Vivado         | +          | +          | 0                  | +                             | -                |



| Board und IDE                     | Synthese-Dauer | Synthese-Fehlererkennung | Editorqualität     |
| --------------------------------- | -------------- | ------------------------ | ------------------ |
| Lattice iCEstick & Yosys          | +              | --                       | 0                  |
| GOWIN TangNano 9k & FPGA Designer | ++             | 0                        | +                  |
| Digilent ARTY S7 & Vivado         | -              | ++                       | 0                  |

Fazit:
Insgesammt erhält der iCEStick 16 Punkte, das TangNano 9k 26 und das Digilent ARTY S7 19 Punkte
Tang Nano 9K wird für schnelle Tests verwendet. Das System wird letzendlich auf dem Arty S7 integriert.



# 4. Erstellen des Assemblers

Um die korrekte Funktionsweiße des RISC-V CPU zu testen, muss ein Programm im Instruction-Memory des CPU abgelegt werden, damit der CPU diese Anweisungen ausführen kann. Die Daten, die im Hauptspeicher erwartet werden sind die Anweisung der Maschinensprache. Die Umwandlung von Assembler-Anweisungen in Maschinen Sprache wird Kodierung genannt. Ein Assembler hat die Aufgabe RISC-V Assembly Anweisungen zu Kodieren. Die RISC-V ISA definiert exakt, wie die Kodierung ablaufen muss. 

Die Instruktionen des RV32I Kerns sind in sechs Gruppern unterteilt, die mit den Buchstaben R, I, S, B, U und J bezeichnet sind. Einige Instruktionen verwenden Register (Register, R) andere enthalten Parameter aus Daten, die direkt in die Instruction einkodiert werden (Immediate, I). Andere Instruktionen sind für Verzweigungen auf Basis einer Bedingung (Branches, B) und Sprünge ohne Bedingung (Jumps, J) zuständig. Instruktionen die in den Speicher schreiben, gehören der Store-Gruppe (S) an. Die U Instruktionen werden verwendet um 32 bit Werte in Register zu laden, was sich mit einem 32 Bit breiten Anweisungsformat gar nicht beschreiben lässt. U Instruktionen erlauben daher nur Immediate Wert aus 20 bit und füllen die fehlenden 12 bit während der Ausführung im CPU implizit mit 0 auf.

Um die Kodierung zu bewerkstelligen wird im Zuge dieser Studienarbeit ein Assembler in der Programmersprache Java erstellt. Dafür gibt es mehrere Gründe. Java lässt sich (nach der Installation eines JRE oder JDK) auf jedem Bebtriebssystem ausführen. Die Assembler und Compiler aus der GNU toolchain sind nicht ohne weiteres auf Windows ausführbar. Ein weiters Argument ist, dass es ein simples Tool ohne viele Parameter geben sollte um Test-Programm schnell und einfach zu übersetzen. Echte Assembler sind komplizierter zu bedienen und verwenden immer auch ein spezifische Memory Layout für ein Zielsystem (Target) und fügen extra Instruktionen für den Target hinzu. Diese zusätzlichen Instruktionen werden von dem eigenen simplen CPU wahrscheinlich gar nicht unterstützt und das kodierte Programm kann dann nicht verwendet werden. Hier soll es lediglich um einen Assembler für einen sehr simplen RISC-V CPU gehen. Der Assembler kodierte die Anweisungen, bis auf leichte Optimierungen, so wie sie eingegeben worden sind. 

Vor dem Entschluss einen eigenen Assembler zu erstellen, wurde nach Alternativen gesucht. Es gibt einen Online Assembler unter https://riscvasm.lucasteske.dev/. Der Nachteil dieses Assembler ist es, dass er 64 bit RISCV Instruktionen für RV64I ausgibt ohne dass dies irgendwo auf der Seite erwähnt wird. Wenn man einen RISC-V CPU mit eine RV32I Kern erstellt, dann kann dieser Online-Assembler nur eingeschränkt verwendet werden. Wie bereits erwähnt ist die RISC-V GNU Toolchain erst ab einem bestimmten Reifegrad des CPU sinnvoll. Damit wird der Anfang der Entwicklung durch die GNU Toolchain eher erschwert als unterstützt.

An den Assembler ist eine Emulator angeschlossen, der das kodierte Programm direkt ausführen kann. Damit kann die Gültigkeit des Programms erst lokal verifiziert werden um zu verhindern, dass das Programm auf den CPU geladen wird obwohl es an sich fehlerhaft ist. Wenn man ein fehlerhaftes Programm auf dem CPU ausführt, kann man in der Entwicklungsphase nicht unterschieden ob das fehlerhafte Verhalten von dem CPU oder von dem Programm stammt. In diesem Fall werden Fehler eventuell an Stellen gesucht, an denen es gar keine Fehler gibt. Diese Situation soll vermieden werden.

Der Assembler liest Dateien mit RISC-V Assembler Anweisungen ein:

```
__main:
loop_start:
    addi x5, x0, 0x0
    addi x6, x0, 0x0
    lui x7, 0
    addi x7, x7, 2

busy_loop_start:	
    beq x5, x7, 0xC             # if (x5 == x7) jump to loop_end (pc relative jump of +12 bytes)
    addi x5, x5, 1
    jal x0, busy_loop_start     # jal loop head (pc relative jump back -8 bytes)

busy_loop_end:
    lw x6, 52(x0)
    xori x6, x6, 1
    sw x6, 52(x0)

    jal x0, loop_start
```

Der Assembler benötigt das Label __main um den Haupteinsprungpunkt zu finden, damit er diese Adresse an den Emulator geben kann und der Emulator die Ausführung dort im Speicher beginnt. Für den RISC-V CPU auf dem FPGA sollte __main immer so gelegt werden, dass seine Adresse mit 0x00 zusammenfällt, also ganz am Anfang des Programms.

Die Assembler Instruktionen werden dann durch einen Parser basierend auf einer Grammatik für RISC-V Assembly geparst. Der Weg über das Parsing wurde gewählt, da RISC-V Assembly ganze arithmetische Ausdrücke erlaubt. Ein Beispiel ist die Anweisung "jal ra, pc - 176;" Diese arithmetische Ausdrücke können beliebig kompliziert werden und sind nur schwer durch einen manuel entwickelten Parser zu verarbeiten. Erfahrungsgemäß wird der Parser dann letztendlich über lange Zeit fehlerbehaftet sein. Auf lange Sicht macht der Einsatz einer Grammatik Sinn und spart Zeit. Die Aufgabe wird an den Computer übergeben, der die Aufgabe besser erledigt als es ein Mensch könnte.

Das Ergebnis des Parsing ist ein Parse-Tree. Ein Visitor wird über den Parse-Tree geführt. Der Visitor (RISCASMExtractingOutputListener) befüllt einzelne Instanzen der Klasse AsmLine mit den Werten, die er aus den ParseTrees der RISC-V Assembler Zeilen ziehen kann. An dieser Stelle liegt jetzt die RISC-V Assembly Datei in Form einer Liste von AsmLine Objekten im Hauptspeicher vor.

Der nächste Schritt ist das Anwenden einer ersten einfachen Optimierung. Wenn sich im Quellcode lui und addi Anweisungen befinden, kann ein Paar dieser Anweisungen durch eine LI (Load Immediate) Pseudo Instruktion ersetzt werden. Dies erscheint zunächst kontraproduktiv, da ein Assembler eher Pseudoinstruktionen auflösen als erstellen soll. Es ergibt nur dann Sinn, wenn man weiß, das zu einem späteren Zeitpunkt wieder Pseudoinstruktionen aufgelöst werden. Während der Auflösung hat der Assembler die Freiheit die LI Instruktion zu optimieren und es wird eventuel anstelle des lui, addi Paares nur ein lui ausgegeben. Durch dieses Verhalten korrigiert der Assembler eventuel unnötig eingefügt Instruktionen durch den Programmierer. Diese Optimierung wurde übernommen, da andere Assembler das gleiche Verhalten haben und sich die Ergebnisse des eigenen Assemblers nur mit anderen Assemblern gegenprüfen lassen, wenn man diese Optimierung auch anwendet.

TODO: Füge eventuell Beispiel einer Optimierung ein:

Im Folgenden erstellt der Assembler eine Tabelle von .equ Konstanten mit deren Werten, damit er Konstanten in Parametern, Expressions und Labeln durch numerische Werte ersetzen kann.

TODO Füge eventuel .equ Beispiel ein, das die Ersetzung zeigt.

Nach dem Ersetzen der Konstanten werden Pseudo-Anweisungen aufgelöst. Beispielsweiße wird ein NOP Pseudo-Anweisung durch ein ADDI Befehl ersetzt, wobei die ADDI Operation keinen Effekt haben darf. Es wird eine ADDI Instruktion ausgegeben, die den Wert 0 auf das ZERO Register addiert! Dieser Ablauf ändert absolut nichts am Zustand der CPU außer, dass ein CPU Zyklus verbraucht wird und sich der Program Counter (PC) auf die folgende Anweisung verschiebt.

In diesem Abschnitt wurde zuvor erwähnt, dass LI Anweisung später aufgelöst werden. Dieser Zeitpunkt ist jetzt gekommen. Nachdem Auflösen der anderen Pseudo-Instruktionen wird nun auch LI aufgelöst. Dabei wird geprüft, ob die LI Anweisung ein Label als Immediate-Wert verwendet. Wenn ein Label verwendet wird, dann wird die Adresse des Labels ermittelt und die Differenz zwischen der aktuellen Adresse und der Label-Adresse gebildet. Wenn die Differenz mit einem simplen LUI geladen werden kann, dann wird nur ein LUI ausgegeben, ansonsten wird eine Kombination aus ADDI und LUI ausgegeben.

Jetzt wird der Call-Optimizer aufgerufen. Wenn eine Routine angesprungen wird, hat der Programmierer meherer Möglichkeiten den Sprung zur Routine zu implementieren. Wenn die Routine innerhalb eines Megabyte relativ zur aktuellen Adresse zu finden ist (near call), dann reicht eine einzige JAL Instruktion. Wenn die Routine außerhalb des Megabyte zu finden ist (far call) dann wird eine Kombination aus AUIPC und JALR ausgegeben.

Nachdem alle Pseudo-Instruktionen durch echte Instruktionen ersetzt worden sind und alle Optimierer entschieden haben, ob sie ein oder zwei Instruktionen ausgeben möchten, liegt eine Liste mit ausschließlich "echten" Instruktionen vor. Alle Pseudo-Instruktionen wurden ersetzt. Auf dieser Liste werden jetzt relative Offsets ersetzt. Relative Offsets werden mit f und b und einem Label-Namen notiert. Der Assembler muss im Falle von f das erste folgende Label finden und im Falle von b das erste vorhergehende Label finden. Das gefundene Label wird dann durch seine Adresse ersetzt.

Siehe folgendes Beispiel von https://marz.utk.edu/my-courses/cosc230/book/example-risc-v-assembly-programs/ in dem 1f und 1b verwendet wird. 1 ist hier ein Label, dass doppelt verwendet wird, einmal in f-Richtung und einmal in b-Richtung aufgelöst werden muss.

```
.section .text
.global strlen
strlen:
    # a0 = const char *str
    li     t0, 0         # i = 0
1: # Start of for loop
    add    t1, t0, a0    # Add the byte offset for str[i]
    lb     t1, 0(t1)     # Dereference str[i]
    beqz   t1, 1f        # if str[i] == 0, break for loop
    addi   t0, t0, 1     # Add 1 to our iterator
    j      1b            # Jump back to condition (1 backwards)
1: # End of for loop
    mv     a0, t0        # Move t0 into a0 to return
    ret                  # Return back via the return address register
```

Im Anschluss werden arithmetische Ausdrücke ausgerechnet und das Ergebnis in Form eines numerischen Werts in die Instruktion eingesetzt. Danach werden die Modifier HI() und LO() ersetzt, die das High-Byte oder das Low-Byte aus einem Wert herauslösen.

Der allerletzte Schritt ist es jetzt den Encoder auf jede AsmLine anzuwenden welcher MaschinenCode für die AsmLine ausgibt. Dieser Vorgang wird für alle AsmLines im Hauptspeicher ausgeführt. Damit hat der Assembler die Eingabe an den RISC-V CPU erzeugt. Der Maschinen-Code wird auf die Kommandozeile ausgegeben und kann von dort kopiert werden.

# 5. Architektur des Pipelined RISC-V CPU

Das Design des RISC-V Pipelined CPU basiert auf dem Design aus dem Buch [111][Digital Design and RISC-V Computer Architecture von Harris & Harris]. 

Das Buch selbst gibt einen RV32I Kern vor, der vollständig in Verilog und auch VHDL angegeben ist und nur eine Teilmenge der Befehle des RV32I Umfangs unterstützt. Der im Buch vorhandene Code implementiert einen Single Cycle CPU, der keine Pipeline besitzt. Damit durchläuft er alle benötigten Phasen (Fetch, Decode, Execute, Memory Access und WriteBack) für jeden einzelnen Befehl bis ein einziger Befehl abgearbeitet ist, bevor er mit der nächsten Anweisung fortfährt. Damit nutzt der CPU seine Resource nicht effizient und erreicht dabei auch nur einen niedrigen Durchsatz an Befehlen.

In einer zweiten Ausbaustufe, wird die Architektur dann von den Autoren um einzelne Phasen erweitert. Für die zweite Stufe und alle folgenden Stufen gibt es im Buch keinen Quellcode mehr. Das Buch beschreibt lediglich die Architektur und bespricht die Wirkungsweiße. Die letzte Ausbaustufe verwendet die einzelnen Phasen und erweitert den RISC-V CPU um eine Pipeline, die an mehr als nur einer Anweisung gleichzeitig arbeitet. Diese dritte Aufbaustufe wird ebenfalls nur beschrieben aber nicht durch Quellcode angegeben. Diese Studienarbeit implementiert diese letzte Ausbaustufe in Verilog.

Die Phasen in einer Pipeline anzuordnen erlaubt es der CPU jede Phase für einen anderen Befehl zu verwenden. Dies wird möglich, wenn man zusätzliche Hardware einfügt und damit Redundanzen schafft. Dies wird beispielsweiße für das ALU Modul gemacht, welches mehrfach instantiiert wird. Durch redundante Hardware kann die Pipeline mehr als einen Befehl dafür aber in unterschiedlichen Phasen bearbeiten.

Um alle benötigten Informationen durch die Pipeline zu führen, werden die Phasen der Pipeline durch sogenannte Pipeline Register getrennt.
Diese Pipeline Register erlauben es beispielweiße die dekodierten Parameter im Datenpfad oder die Steuersignale in der Kontrolllogik parallel zum Befehl durch die Pipeline zu führen, damit sie immer verfügbar sind, wenn sie gebraucht werden.

## Design

Eine Übersicht über das Design wird in der Abbildung xyz gegeben:

TODO: Hier Bild 7.61 von Seite 453 aus [111] einfügen

Hier ist die Kontrolllogik und die HazardUnit am unteren Rand der Abbildung in blauer Farbe und der Datenpfad in der Mitte in schwarzer Farbe dargestellt.

### Datenpfad

Im Grunde besteht der Datenpfad aus der Hardware, die den CPU ausmacht. Es sind Speicher, Sign-Extender, Multiplexer und die redundante ALU enthalten. Der Datenpfad verarbeitet die Phasen der Pipeline in getakteter Form basierend auf dem Clock-Signal. Ohne geeignete Steuersignale können die Multiplexer nicht entscheiden, welche Daten sie auswählen und weitergeben. Ohne Steuersignale weiß die ALU auch nicht, welche Operation sie ausführen soll. Die Steuersignale stammen aus der Kontrolllogik.

### Kontrolllogik

Die Kontrolllogik besteht aus kombinatorischer Logik. Ihre Aufgabe besteht darin die Information so zu kombinieren, dass sie die korrekten Steuersignale für jeden Befehl and den Datenpfad weitergeben kann. In diesem Sinne konfiguriert sich der Datenpfad über die Multiplexer dann ständig um, um dem aktuellen Befehl gerecht zu werden. Der Datenpfad passt sich an die Befehle an.

Die Kontrolllogik wird durch das Modul "controller" in der Datei controller.v implementiert. Die Eingabe-Ports werden mit den dekodierten Feldern der aktuellen Instruktion nach der FETCH Phase gespeist. Die Ausgaben des Moduls entsprechen allen Linien, die aus der Kontrolllogik in den Datenpfad und die Hazard-Unit reichen.

Das Controller Modul enthält hauptsächlich die eingebettete Kontrolllogik des SingleCycle Designs. Des weiteren sind lediglich die notwendigen Pipeline Register enthalten um die Daten durch die Pipeline zu führen. Die SingleCycle Controlllogik besteht aus dem MainDecoder und dem AluDecoder. Der MainDecoder entnimmt der Instruction durch Dekodierung die Steuersignale für den Datenpfad. Der AluDecoder entnimmt der Instruktion die Operation, die die ALU ausführen muss.

Während der Entwicklung wurde zu Beginn ein schwerer Fehler begangen, der sehr viel Zeit gekostet hat. Das Buch [111] stellt beispielsweiße auf Seite 436 eine Zustandsmaschine für die Ausführung der Kontrolllogik dar. Hiervon inspiriert wurde die erste Version der Kontrolllogik als ebendiese Zustandsmaschine implementiert. Das Design hat teilweiße funktioniert und wurde daher in zeitraubender Feinstarbeit debugged und angepasst. Es kam aber nie zu einer Situation in der alle Testanwendungen ausgeführt werden konnten. Letztendlich lies sich die Funktion mit diesem Design nicht bewerkstelligen. Sich dieses Umstands bewusst zu werden ist für einen Anfänger ohne Erfahrung extrem schwer. Der Anfänger weiß nicht ob seine Programmierung fehlerhaft ist oder das verfolgte Konzept grundlegend nicht zum Erfolg führen kann.

Nach dem Ausschöpfen aller Ideen wurde die Idee der Zustandsmachine durch eine rein kombinatorische Implementierung der Kontrolllogik ohne jeglichen Zustand (bis auf die Pipeline Register) ersetzt. Diese Implementierung brachte den gewünschten Erfolg und die gewünschte Funktionalität und ist gleichzeitig um ein vielfaches kompakter als die Zustandsmaschine. Der Fehler lag im Verständnis der Aufgabe der Kontrolllogik. Die Kontrolllogik musse die Steuersignale kombinatorisch aufgrund der aktuellen Eingabe produzieren und muss darüberhinaus keinen Zustand haben. Eine Zustandsmaschine ist an dieser Stelle konzeptionell das falsche Modell.

Liegen die erzeugten Steuersignal einmal vor, werden sie in die Pipeline-Register eingezetzt und bewegen sich ab dann parallel zur Instruktion durch die Pipeline bis der Befehl abgearbeitet ist.

### Data Hazards und die Hazard Unit

Eine Pipeline soll den Durchsatz eines CPU erhöhen indem Sie optimalerweiße vollumfänglich mehrere Befehle ausführt. Die Effizienz einer strikt entworfenen Piepline ist nicht in allen Fällen auf 100 Prozent. Manchmal folgen Befehle aufeinander, so dass die Informationen für den zweiten Befehl aus dem ersten Befehl kommen und daher nicht direkt verfügbar sind. Daher muss eine strikte Pipeline angepasst werden um den Durchsatz auch bei ungünstigen Befehlsfolge zu erhöhen. Diese ungünstigen Situation werden Hazards genannt.

Es gibt unterschiedliche Arten von Hazards. Neben Hazards, die sich durch zustätzliche Hardware lösen lassen, gibt es Hazards, die lediglich durch einen Pipeline Stall beseitigt werden können. Die HazardUnit hat die Aufgabe Hazards zu erkennen und Steuersignale auszugeben, die die Pipeline in die Lage zu versetzen Befehle korrekt zu Ende zu führen, auch wenn ein Hazard vorliegt. Die HazardUnit ist in hazard_unit.v implementiert. 

Data Hazards ergeben sich in folgender Befehlsfolge:

```
add s8, s4, s5
sub s2, s8, s3
```

Das Ergebnis der Addition steht erst nach der WriteBack-Phase im Register s8, wird aber bereits in der folgenden Execute-Phase von dort gelesen. Zur Lösung dieses Problems aktiviert die Hazard Unit ihr ForwardAE oder ForwardBE Signal. Durch eine explizit hinzugefügte Leitung kann das Ergebnis einer Operation direkt in der vorhergehenden Phase gemultiplext werden. Der Multiplexer wird dabei durch die Signale ForwardAE oder ForwardBE gesteuert. Siehe Figure 7.55 auf Seite 447. Um die Verwendung der Register erkennen zu können werden der HazardUnit die Parameter aus dem Decoding des Befehls zugeführt. Hazards werden anhand einer logischen Bedingung beschrieben und lassen sich dadurch erkennen.

Es gibt Hazards, bei denen ein berechneter Wert aus der Zukunft abgeholt werden müsste um eine Berechnung durchzuführen. Da man nicht in die Zukunft reisen kann bleibt nur ein Ausweg. Es wird auf den Wert gewartet, den es noch nicht gibt. Warten in einer Pipeline wird Stall genannt. Jede Phase in der Pipeline hat einen Stall- bzw. Enable-Eingang. Das Stall Steuersignal wird von der HazardUnit aufgrund einer logischen Bedingung berechnet. Wenn eine Pipeline Stage-gestallt wird, als nicht enabled ist, führt sie einfach keine Aktion aus, behält aber ihren Zustand wie gehabt bei, so dass sie später fortfahren kann, wenn die benötigten Information vorliegen. Ein Beispiel das einen Stall auslöst ist

```
lw s7, 40(s5)
and s8, s7, t3
```

Der Wert aus dem Speicher ist zu dem Zeitpunkt an dem die AND-Operation mit t3 erfolgen soll noch gar nicht aus dem Speicher geladen worden. Die AND-Operation muss daher noch einen Clock-Zyklus warten, bis der Wert geladen ist. Die Execute-Stage muss bereinigt werden, während die Dekode Phase und die vorhergehende Fetch Phase beide gestallt werden müssen! Nun kann die AND-Operation aus der Decode-Phase in die Execute-Phase übergehen, und der aus dem Speicher geladene Wert wird der AND-Operation zugeführt. Das Löschen der Daten in der Execute-Phase ist notwendig, da sonst inkorrekte Daten durch die Pipeline laufen und zu falschen Ergebnisse führen könnten.

Die letzte Gruppe der Hazards hinterlässt Überreste angefangener Befehle in Pipeline wobei diese angefangenen Befehle niemals zu Ende geführt werden dürfen. Dies geschieht bei Branches, die Befehle überspringen. Ob ein Branch tatsächlich ausgeführt wird ist erst klar, wenn die folgenden Befehle bereits in die ersten Phasen der Pipeline gelangt sind. Die Hazard Unit erkennt den Hazard indem sie das PCSrcE Signal überwacht, dass Branches aktiviert oder eben nicht. PCSrcE besteht aus einer eignen Logik in der Control-Logik. Das PCSrcE Signal wird er HazardUnit zugeführt. Um die Pipeline Stages zu löschen, gibt die HazardUnit Flush-Signale an die Clear-Eingänge der PipelineRegister aus. Damit führt ein Flush Kontrollsignal dazu, dass die Pipeline Register ihren Inhalt vergessen bzw. löschen. Durch das Löschen gelangen die halb abgearbeiteten Befehle nicht in die hinteren Phasen der Pipeline und führen damit keine fehlerhaften Aktionen aus.

Der Code in dem HazardUnit Modul hat keinen Zustand und besteht lediglich aus logischen Kombinationen, die aus den Eingabesignalen die Steuersignale berechnen.






# 6. RISC-V Debug Spezifikation (RISC-V External Debug Support)

Quellen: 
[100] https://five-embeddev.com/riscv-debug-spec/v0.13-release/core_debug.html
[101] https://riscv.org/wp-content/uploads/2024/12/riscv-debug-release.pdf

Die Interaktion mit einem Computer erfolgt über Ein- und Ausgabeperipherie. Dabei sind auf den Entwicklungsboards üblicherweiße Slider, Knöpfe, LEDs, Displays oder 7-Segment-Anzeigen vorhanden. Möchte man direkt über den Zustand des CPU oder der an den Systembus angeschlossen Module wie Speicher oder UARTs informiert werden, sind die Perihperie und simple Tests meist nicht detailiert genug.

Einen direkten Zugriff auf die Register und den Speicher erhält man über einen Debugger. Ein Debugger kann nur funktionieren, wenn die Zielhardware Funktionen bereitstellt, die der Debugger nutzen kann. Der Debugger muss darüber hinaus überhaupt erst über eine Infrastruktur mit dem CPU verbunden werden.

Die Spezifikation für den Debug Support heißt "RISC-V External Debug Support" [101] und wird im Folgenden Debug-Spezifikation genannt. Der RISC-V External Debug Support ist keine RISC-V Extension, sondern eine Richtlinie für eine Implementierung.

Um die Debug-Spezifikation zu verstehen ist es wichtig unterschiedliche Ebenen voneinander zu trennen, da ansonsten schnell Verwirrung entsteht. Die Ebenen, die zu trennen sind, sind die konkrete Implementierung der Infrastruktur (hier JTAG und Wishbone) und die Module die spezifisch für RISC-V definiert werden (DTM, DMI, DM und Harts).

TODO: Hier Bild von Seite 6 der Debug_Spec darstellen.

Um den RISC-V Anteil zu beschreiben, beginnen wir auf dem Endbenutzergerät (PC oder Laptop), auf dem die Debugger-Software läuft. Im Zuge dieser Studienarbeit werden Python-Skripte erstellt, die die Aufgabe eines Debuggers übernehmen. Die Debugger-Software spricht mit einer Debug-Probe, welche die Signale auf das Entwickler-Board überträgt, auf dem das RISC-V System läuft. Die Debug-Spezifikation bezeichnet das RISC-V System als RISC-V Platform. Die RISC-V Debug Spezifikation gibt nicht vor, welche Technologie zur Übertragung der Signale verwendet werden muss. Dazu später mehr.

Innerhalb der RISC-V Platform wird die Verbindung zunächst am Debug Transport Module (DTM) terminiert. Es kann in einer RISC-V Platform mehrere DTM Implementierungen geben. Beispielsweiße könnte ein DTM über USB sprechen, eine andere Implementierung eines DTM über JTAG. An dieser Stelle bleibt die konkrete Implementierung noch abstrakt und spielt erstmal keine Rolle für die weitere Beschreibung der Debug-Spezifikation.

Der DTM verwendet das Debug-Module-Interface (DMI) um mit einem oder mehreren Debug-Modulen (DM) zu sprechen. Das Debug-Module-Interface definiert Register und Befehle im DTM, die eine Kommunikation mit dem DM auslösen. Der Debugger muss diese Befehle schicken um bestimmte Aktionen innerhalb der RISC-V CPU auszulösen.

Die RISC-V CPU besteht aus mindestens einem Hart. Ein Hart besitzt Hardware um Instruktionen auszuführen (Eine Pipeline samt Registern und eine oder mehrere ALU). Fortschrittliche RISC-V CPUs können viel Harts enthalten um echtes Multithreading zu ermöglichen. Ein Debug-Module (DM) ist für einen oder mehrere Harts gleichzeitig zuständig. Eine RISC-V Platform kann eine oder mehrer DM enthalten.

Der DTM muss im ersten Schritt die Anzahl der DMs ermitteln und dann DMs auswählen. Die momenten ausgewählten DMs erhalten dann Befehle vom DTM, die sie dann auf ihren Harts ausführen sollen. Mit diesen Befehlen kann ein DTM kann die DMs anweißen ihre Harts zu pausieren, zu reseten und weiterlaufen zu lassen. Es ist auch möglich die Register der Harts zu lesen, zu schreiben. Über den Systembus ist es möglich mit dem Speicher (RAM für Instruktionen und Daten) zu interagieren und den Speicherinhalt zu lesen und zu schreiben.

Die RISC-V Platform, die im Zuge dieser Arbeit erstellt wird, besitzt einen einzigen Hart um die Komplexität für Anfänger handhabbar zu gestalten. Aus dem gleichen Grund wird nicht jeder Teil der Debug-Spezifikation implementiert. Das Zählen und das Auswählen der DMs wird nicht implementiert. Es wird implizit von einem einzigen Hart ausgegangen der automatisch immer ausgewählt und damit immer das Ziel aller Befehle ist.

Die noch zu beschreibenden Teile sind die konkrete Implementierung zur Übertragung der Daten zwischen der Debug-Probe und dem DTM innerhalb der RISC-V Platform. Wie oben beschrieben, muss die Debugger-Software DMI-Befehle im DTM auslösen. Dazu muss sie diese DMI-Befehle übertragen. Innerhalb dieser Studienarbeit wird dazu JTAG verwendet.

JTAG ist ein Protokoll das zum Testen von Hardware eingesetzt wird. Es erlaubt neben dem Ausführen von Hardwaretestabläufen auch das Schreiben in Register und in den Speicher und wird daher auch häufig eingesetzt um Mikrokontroller-Firmware zu flashen. Innerhalb der JTAG-Beschreibung gibt es den TAP. Der TAP befindet sich im Zielsystem und terminiert dort die JTAG Verbindung. Da diese Aufgabe beinahe deckungsgleich mit dem DTM aus der RISC-V Debug Spezifikation ist, wird ein JTAG TAP als RISC-V DTM ausgeführt oder alternativ wird ein TAP direkt mit dem DTM verbunden. In dieser Studienarbeit sind DTM und JTAG-TAP ein und dasselbe Modul.

JTAG ist in der Lage Register zu beschreiben. Die Interaktion zwischen dem JTAG Protokoll und dem RISC-V DTM besteht also darin, dass der JTAG-TAP in die Register des DTM schreibt. Die RISC-V Debug Spezifikation ist so ausgeführt, dass das Beschreiben eines Registers Aktionen direkt startet. Damit ist JTAG ein perfektes Protokol um die RISC-V Debug Spezifikation auszuführen. JTAG kann also dazu genutzt werden DMI-Befehle auszuführen, in dem das DMI Register des DTM über JTAG beschrieben wird.

Die RISC-V Platform ist jetzt also in der Lage DMI-Befehle zu starten. Das Debug-Module-Interface (DMI) ist das Protokoll zwischen einem DTM und mehrern DMs. Die Frage ist, wie diesee Datenübertragung in Hardware implementiert wird. Die RISC-V Debug Spezifikation überlässt dieses Detail der Implementierung und macht absolut keine Vorgaben. In der Debug-Spezifikation wird nirgends definiert, wie eine DMI-Transaktion gestartet oder gestoppt wird. Der verwendet Wortlaut ist absichtlich abstrakt und es wird von "Lesen" und "Schreiben" gesprochen. Im Zuge dieser Studienarbeit wird die Interaktion über den Wishbone Bus implementiert. Der Wishbone Bus ist gut dokumentiert (TODO: B4 Spec hier verlinken) und ohne Lizenzgebühren einsetzbar. Der Wishbone Bus ist von der Komplexität her minimal im Vergleich zu anderen Bussystemen (AMBA-Bus, AXI-Bus, ...).

Für einen einfachen Debugger sollen folgende Funktionen implementiert werden:
- Hart stoppen, reseten und starten und im Single Step modus ausführen sowie die normale Ausführung wieder anfnehmen.
- Register lesen schreiben
- Speicher lesen schreiben

Mit diesen Funktionen kann ein Program auf den RISC-V CPU geladen werden und das Programm kann im Single-Step Betrieb ausgeführt werden.

Um den Hart zu stoppen, hat der DM Kontroller über die Hardware Clock-Source, die den Hart mit einem Taktsignal verorgt. Wenn die Clock-Leitung unterbrochen wird, dann ist der Hart gestoppt. Zum Single-Step Betrieb generiert der DM ein eigenes Clock-Signal und führt dem Hart dieses Clock-Signal zu. Wenn der Hart fortgesetzt wird, dann wird die Hardware Clock-Source wieder zugeführt.

## JTAG State Machine

JTAG ist ein sehr allgemeines System. Für JTAG besteht jedes Gerät aus Registern. JTAG definiert das Vorhandensein der Register IR (Instruction Register), BYPASS und weitere Datenregister, über die jedes Gerät selbst entscheiden kann. Jedes Gerät sollte jedoch zumindest ein IDCODE Datenregister haben. Jedem Register wird ein Code zugeordnet. Das IR-Register wird verwendet um die Codes aufzunehmen und damit das zum Code gehörige Register zum aktuellen Register zu machen. Zu jedem Zeitpunkt kann nur ein einziges Datenregister oder das BYPASS Register aktiviert sein. Das IR Register ist parallel dazu immer aktiv. Man kann immer Codes ins IR Register laden. JTAG schreibt vor, dass beim Start des Systems das IR Register so befüllt sein muss, dass das IDCODE Datenregister vorausgewählt wird. Das IDCODE Register enthält eine Beschreibung des Geräts.

Die Art und Weiße, wie mit Registern interagiert wird ist verblüffend, wenn man sich zum ersten mal mit JTAG auseinander setzt. JTAG ermöglicht es mit lediglich vier Steuersignalen Register beliebiger Breite in einem Schreibzyklus zu beschreiben. Dazu findet ein Umsetzung der seriellen Signale zur Übertragung in eine Parallele Verarbeitung der Signale zum tatsächlichen Schreiben der Register statt. Es wird zunächst ein Shift-Register seriell befüllt und dann das Schreiben in einem einzigen Schritt parallel ausgeführt. Die Serielle Befüllung dauert mehrere Zyklen. Das Beschreiben geschieht in einem einzigen Zyklus.

Zunächst definiert JTAG eine Zustandsmaschine aus 16 Zuständen. Die Zustandsmachine hat grundsätzlich zwei Arme. Ein Arm aktiviert das Shift-Register für IR und lädt Daten aus dem IR Register in das IR-Shift-Register. Der andere Arm führt die entsprechenden Funktionen für das aktuell ausgewählte Datenregister oder BYPASS Register aus.

TODO: Bild der StateMachine

Jedes JTAG Gerät muss intern diese JTAG Zustandsmaschine ausführen. Die Zustandsmaschine ist im JTAG TAP enthalten. Ein Gerät kann einen oder mehrere JTAG TAPs (Test Access Port) aufweißen. Mehrere Geräte mit jeweils mehreren TAPs können Teil einer JTAG Verbindung sein. In JTAG wird nicht über eine Punkt-zu-Punkt Architektur kommuniziert, es wird stattdessen eine Daisy-Chain aus JTAG TAPs gebildet. Dabei werden alle Shift-Register aller TAPS in einer langen Daisy-Chain aneinander gehängt! Alle Bits werden von Anfang bis Ende durch diese Daisy Chain geschiftet und durchlaufen dabei alle Shift-Register aller TAPs! Durch diesen minimalistischen Ansatz ist das System über nur vier Signale steuerbar. 

TODO Bild der Daisy Chain aus Vivado
TODO: Bild Figure 2 von Medium einfügen. (https://medium.com/@aliaksandr.kavalchuk/diving-into-jtag-protocol-part-1-overview-fbdc428d3a16)

Alle Zustandsmachinen in allen JTAG TAPs der DaisyChain befinden sich zu jedem Zeitpunkt im gleichen Zustand und führen synchron Transitionen aus. Um die synchronen Transaktionen zu ermöglichen sind die JTAG Steuersignale Test Clock (TCK) und Test Mode Select (TMS) parallel an alle JTAG TAPs angeschlossen. Die Steuersignale Test Data In (TDI) und Test Data Out (TDO) sind im Falle von TDO am Anfang der DaisyChain und im Falle von TDI am Ende der DaisyChain angeschloßen. Es ist damit möglich gleichzeitig ein Bit einzushiften (TDI) und dabei gleichzeitig ein Bit zu lesen, das in TDO ausgeschiftet worden ist.

TODO eventuell einfügen Bild Seite 29 von https://tu-dresden.de/ing/informatik/ti/vlsi/ressourcen/dateien/dateien_studium/dateien_lehstuhlseminar/vortraege_lehrstuhlseminar/hs_ws_0708/jtag-schnittstelle.pdf?lang=de

Mit JTAG ist es also möglich Werte in Register zu schreiben, zu warten und dann Werte aus Registern zu lesen. Oft werden Operationen in den Geräten angestoßen, sobald ein Register mit einem Wert beschrieben worden ist. Dabei wird ein bestimmter Wert in ein Shift-Register geschiftet. Wenn dann im Zustand UPDATE-DR der Wert aus dem Shift Register in das echte Datenregister zurückkopiert wird, findet die Ausführung der Operation statt. Die RISC-V Debug Spezifikation definiert Register und eine Reihe von Operationen, die durch das Schreiben bestimmter Register angestoßen werden. Damit ist JTAG eine passende Infrastruktur um die RISC-V Debug Spezifikation zu implementieren.

## Implementierung in Verilog

Die JTAG Zustandsmachine ist in jtag_tap.v zu finden. Das Modul besitzt die Signale jtag_clk, jtag_tms, jtag_tdi und jtag_tdo. Ein Always-Block reagiert auf die negative Flanke der JTAG Clock und shifted ein Bit aus jtag_tdo aus. Ein anderer Always-Block regiert auf die positive Flanke der JTAG Clock und bestimmmt den nächsten Zustand der Zustandsmaschine. Dieser Block führt auch Aktionen aus, die für die jeweiligen Zustände ausgeführt werden sollen.

Wenn CAPTURE_DR betreten wird, wird abhängig vom IR Register das gewählte Datenregister in das entsprechende Shift-Register übertragen. Entsprechendes gilt für das IR-Shift- und IR-Datenregister, wenn CAPTURE_IR betreten wird.

Im SHIFT_DR Zustand wird zunächst das TDO Bit aus dem aktuellen Shift-Register für die folgende fallende Flanke gespeichert. Dann wird das Shift-Register um eine Position geshiftet und gleichzeitig das TDI-Bit in das Register einfügt wird. Für den SHIFT_IR Zustand gilt entsprechendes. Die Zustände EXIT1, EXIT2 und PAUSE sind weder für die Datenregister noch für die IR Register mit Aktionen belegt. Im UPDATE_DR Register wird das Shift-Register in das Datenregister zurück kopiert. Dabei wird dieser Zeitpunkt auch verwendet um Aktionen anzustoßen. Beispielsweiße wird im Falle des DTM.dmi Register eine DMI Transaktion über den Wishbone Bus mit dem DM aktiviert.

## RISCV Abstract Commands

Dieser Abschnitt beschreibt die Implementierung der Befehle, mit denen der Speicher gelesen und geschrieben werden kann. 

Die RISC-V Debug Spezifikation gibt an, dass es mehrere Möglichkeiten gibt auf den Speicher zuzugreifen. Diese Möglichkeiten werden im Abschnitt B.2.7 Reading Memory aufgelistet. 

Die erste Möglichkeit ist es über den System-Bus direkt auf den Speicher zuzugreifen. Dazu definiert die Debug-Spezifikation eine Menge von Registern im DM. (Diese Register werden über das DTM.dmi Register über Wishbone geschrieben und gelesen.) Um Speicher zu lesen oder zu schreiben wird eine Kombination aus sbcs, sbaddress0 und sbdata0 verwendet. Der Speicherzugriff über den Systembus geht am System der Privilegien im RISC-V CPU vorbei und bietet vollen Zugriff auf den Speicher. Diese erste Option trifft implizit die Annahme, das der Speicher über ein Bussystem mit dem Hart verbunden ist. Das muss nicht immer der Fall sein.

Die zweite Möglichkeit ist es, den Program Buffer zu verwenden. Man lädt eine kleine Menge an RISC-V Maschinen Code in den Program Buffer, dessen Funktion das Lesen oder Schreiben des Speichers ist und führt den Hart auf dem Program Buffer aus, anstelle auf dem Instruction-Memory.

Eine dritte Möglichkeit sind abstrakte Commandos. Abstrakte Commandos werden laut Debug Spezifikation mit den Privilegien des Harts ausgeführt werden, dabei muss aber nicht zwangsweiße der Hart selbst verwendet werden. Theoretisch könnte abstrakte Kommandos also implementieren, indem man ein vorgefertigtes Programm in den Program Buffer lädt und den Hart ausführt. Alternativ sind andere Implememtierungen erlaubt.

In dieser Studienarbeit wird der dritte Ansatz ausgewählt. Dabei wird kein Program Buffer verwendet. Da der simple Hart keine Privilegien implementiert ist das System konform zur Debug Spezifikation, wenn der DM den Speicherzugriff einfach direkt selbst implementiert und ausführt. Es wird einfach direkt auf den Speicher zugegriffen. Dabei wird kein Bus zwischen DM und Speicher verwendet, da der simple RISC-V CPU keinen internen Bus besitzt.

## Zusammenfassendes Beispiel

Das Schreiben in den Speicher über JTAG innerhalb der RISC-V Debug Spezifikation umfasst folgende Abfolge. Zunächst muss ein DMI Command abgesetzt werden, damit der DTM in den DM schreibt. Dazu wird der DMI Command in das DTM dmi register geschrieben. Der DMI Command ist ein Schreibbefehl in das Control Register des DM. Der Wert, der in das DM control Register geschrieben wird ist ein Abstract Command. Diese Abstract Command schreibt einen Wert in den Speicher. Der Wert der in den Speicher geschrieben wird, wird im Data0 register erwartet, die Adresse an die geschrieben wird, wird im Data1 Register erwartet. Streng genommen muss also vor dem Ausführen des Abstract Commands also zunächst Data0 und Data1 geschrieben werden. Wenn der Abstract Command ausgeführt worden ist, gibt es keinen Rückgabewert!

Das Lesen aus dem Speicher erfolgt ebenfalls über einen Abstract Command. Dieser startet ebenfalls dadurch, dass ein DMI Command, welcher einen Wert in das DM Command Register schreibt, in das DTM dmi Register geschrieben wird. Damit wird der DMI Command in den DM schreiben. Die Adresse von der gelesen werden soll, muss sich im Register Data1 befinden. Der aus dem Speicher gelesene Wert wird im Data0 Register zurückgegeben. Von dort kann er mit einem anderen Abstract Command abgefragt und an den Debugger über JTAG zurückgegeben werden.

## Debug Probe und Python Skripte

Es gibt JTAG DebugProbes wie z.B. den Segger J-Link, den Jtagulator oder den simpleren GoodFet. Da die Implementierung in dieser Studienarbeit keine volle JTAG Implementierung liefert, wird eine einfache Umsetzung über einen Arduino DUE erstellt. Der Arduino Due kommuniziert über UART mit einem PC auf dem Python Skripte ausgeführt werden und setzt auf der anderen Seite Kommandos in die vier Signale JTAG_TMS, JTAG_CLK, JTAG_DTI und JTAG_DTO um.

Anbei ein kleiner Auszug, der zeigt, wie der Arduino die Zustandsmachine antreibt, indem er das TMS eintaktet:

```
for (size_t i = 0; i < len; i++) {

    // determine next bit to send out
    uint8_t bit = *in_data & 0x01;
    *in_data >>= 1;

    delay(delay_in_ms);
    digitalWrite(jtag_clk, LOW);
    jtag_clk_state = LOW;
      
    digitalWrite(jtag_tms, tms_data);
    digitalWrite(jtag_tdo, bit);

    delay(delay_in_ms); 
    digitalWrite(jtag_clk, HIGH);
    jtag_clk_state = HIGH;

    // cause negedge and read data
    delay(delay_in_ms);
    digitalWrite(jtag_clk, LOW);
    jtag_clk_state = LOW;

	// combine read bit into returned value
    delay(delay_in_ms);
    int val = digitalRead(jtag_tdi);
    *read_data >>= 1;
    *read_data |= (val << 7) << 24;
}
```

Das Protokoll zwischen den Python Skripten und dem Arduino definiert ein einfaches Datenformat und lediglich drei Kommandos. Das Ping Kommando wird mit einem Pong beantwortet und dient lediglich zum Test ob der Arduino antwortet und folglich ob man das Protokollformat korrekt implementiert hat. Es werden keine JTAG Daten aufgrund des Ping Pong übertragen. Der SEND_TMS Kommand kann verwendet werden um die StateMachines anzutreiben ohne Daten über TDI zu schicken. Das letzte Kommando ist SHIFT_DATA. Hier wird eine Menge an Bits über TDI in alle StateMachines geschiftet. Dabei kann angegeben werden, welches Signal an TMS angelegt werden soll. Dies ist notwendig um ein Register bis auf das letzte Bit zu füllen und dann zusammen mit dem letzten Bit auch ein TMS Signal zu schicken, mit dem die StateMachine dann angewießen wird den Shift-Zustand zu verlassen, so dass das Register "versiegelt" wird und keine falschen Daten mehr in das Register gelangen! Register werden nämlich nur während des Shift Zustandes mit Daten aus TDI versorgt.

Innerhalb der Python Skripte wird mit der Zustandsmaschine umgegangen um bestimmte Register auszuwählen und Daten in diese Register zu shiften. Damit lassen sich die Abfolgen für abstrakte Kommmandos ausführen.

# Abschluss und Ausblick.

Es wurde Hardware und Software verglichen, bewertet und ausgewählt um einen einfachen RISC-V Kern mit einer Pipeline zu implementieren. Das Design wurde beschrieben. Das RISC-V Systems wurde um eine Programmierschnittstelle per JTAG unter verwendeung der RISC-V Debug-Spezifikation erweitert. Damit ist das System um eigene Software erweiterbar. Die Software kann durch einen eigens erstellten Assembler für 32-Bit RISC-V übersetzt und durch einen eigens entwickelten Emulator vorgeprüft werden. 

Damit ist das Ziel einen Studenten eine Weg zur Implementierung eines RICS-V Systems aufzuzeigen erreicht.

Es gibt Teile der Implementierung die vervollständigt werden können. Es sind nicht alle RV32I Befehle im Kern ausführbar. Mehrere interessante Extensions könnten hinzugefügt werden wie beispielsweiße Komprimierte Befehle oder Fließkommaarithmetik. Ein Systembus mit MemoryMapped Peripherie könnte hinzugefügt werden. Damit wird der RISC-V Hart immer mehr zu einem Mikrocontroller Design und kann mit externen Hardwarebausteinen kommunizieren.

Die Übertragung der JTAG Befehle über den Arduino ist funktionsfähig allerdings momemtan sehr langsam getaktet, da die Always-Blöcke, die im FPGA auf die JTAG Clock reagieren oft Bits verpassen oder duplizieren, wenn der Takt angehoben wird. Das ist unverständlich, da die Verbindung langsamer aus ein UART mit Baudrate 115200 ist und damit eigentlich noch einfach für einen FPGA handhabbar sein sollte. An dieser Stelle kann das Verfahren mit echter JTAG Hardware nachgeprüft und die Übertragungsrate angehoben werden. Momentan wurde lediglich die Machbarkeit gezeigt.

Dies ist der Anfang der FPGA Entwicklung. Es ist sehr viel Erfahrung notwendig um funktionierendes Systeme zu bauen. Ein Anfänger kann seine eignen Fehler oft nicht direkt erkennen. Die kommenden Schritte werden sein aus anderen Designs und der Literatur weiter zu lernen.

## Danksagung

Ich bedanke mich sehr herzlich bei Dr. Christian Jakob für die Betreeung der Arbeit und seine Hilfestellung und Ratschläge beim Erstellen dieser Arbeit. FPGAs haben einen sehr hohen Stellenwert für mich und das Erstellen dieser Arbeit bringt mich meinem Ziel sehr viel näher. Nebenbei gesagt, hat die Arbeit mit dem RISC-V System und dem FPGA auch sehr viel Spaß gemacht. In einer Umgebung die aus kleinsten Bausteinen besteht kann mit Kreativität eine vielzahl an Lösungen erstellt werden, auch wenn der Weg zur Lösung oft ein steiniger ist.



