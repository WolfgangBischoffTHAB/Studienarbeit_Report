20 Seiten

# Titel

Implementierung eines RISC-V CPU und Bestandteilen einer Toolchain

# Zielsetzung

Das Ziel dieser Studienarbeit ist es einen Weg und die Mittel aufzuzeigen, mit denen ein Anfänger die Erstellung es einfachen RISC-V CPU bewerkstelligen kann. Das Testen des CPU durch selbstentwickelte Software und das Debuggen der Software auf dem CPU ist ebenfalls Teil der gesetzten Aufgabe.

# Herausforderungen

Die Implementierung eines RISC-V CPU stellt einen Student vor mehrere Herausforderungen.

1. Auswahl der Hardware - Ein FPGA Entwicklungsboard kann zwar von der Bildungseinrichtung beigestellt werden und die Auswahl ist damit vorgegeben. Es kann trotzdem sinnvoll sein sich nochmals über die Wahl des Entwicklungsboards gedanken zu machen, da die Auswahl des Entwicklungsboards Einfluss auf die zu verwendende FPGA-Entwicklungstools hat. Die Verwendung bestimmter FPGA-Entwicklungstools haben selbst wiederum Konsequenzen und will daher gut ausgewählt werden. Ein weiterer Punkt ist der Preis und die Verfügbarkeit der FPGA Boards. Es gibt bereits Boards zu niedrigen Kosten, die sich für das Erlernen der FPGA-Entwicklung eignen.

2. Auswahl der FPGA-Entwicklungstools - Die FPGA Entwicklungstools können vom Hersteller des FPGA gestellt werden. Diese Herstellertools sind im Falle von Vivado (Vom Hersteller AMD für Artix, Kintex, Virtex, Spartan und Zynq 7000 series und auch UltraScale and UltraScale+ Familien) und Quartus Prime (Intel für Cyclone und MAX chips) sehr umfangreich. Vorteile von Intel und AMD sind die Bereitstellung von IP-Bibliotheken und Generatoren. Nachteile sind die schiere Größe dieser Tools (mehrer 100 GB an Festplatten für die Installation). Ein mittleres Angebot wird von kleineren Herstellern wie der Firma Lattice und der Firma GOWIN gemacht. Ihre FPGAs sind teilweiße durch OpenSource Toolchains abgedeckt aber die Herstellereignenen FPGA-Entwicklungstools sind auch eine gute Option und bieten oft einen guten Funktionsumfang bei kleinerem Resourcenverbrauch. Des weiteren geht die Bandbreite bis hin zu OpenSource Tools (Yosys, NextPNR). Die Toolchains werden in einem späteren Abschnitt miteinander verglichen und eine Auswahl wird getroffen.

3. Erlernen der HDLs Verilog, System Verilog oder VHDL. Ausführen von Simulationen und übertragen der Designs auf den FPGA und dortigem Test. Es kann sein, dass Designs trotz funktionierende Simulation nicht auf dem FPGA funktionieren. Die Fehlersuche ist dann sehr schwer, da es keine "Debugger" für FPGAs und deren internen Abläufe gibt. Von Vorteil ist es, wenn die Dauer eines Zyklus von der Änderung des Designs über die Synthese bis zum Upload kurz sind. Verständnis vom Design für Signales (wires) und getackteter, Zustandsbehafteter Logik (register mit clock Flanken).

Auch nachdem die Aufgabe des Designs eines CPU gemeistert ist, gibt es weitere Herausforderungen.

4. Auswahl eines Assemblers - Es gibt wenige Assembler, die RISC-V code in Maschinenbefehle übersetzen und dabei möglichst wenige Annahmen treffen.
Das Problem liegt in einer Diskrepanz zwischen der RISC-V Spezifikation und Lehrbüchern zu RISC-V und den Compilern und Assemblern, die tatsächlich zur Erstellung von Software gentzt werden. Die RISC-V Spezifikation und Lehrbücher sprechen über RISC-V Instruktionen und deren Kodierung in Maschinenbefehle. Wirkliche Compiler haben die Aufgabe Maschinencode auszugeben, der konkrete Speicherbereiche belegt und die Kombination von unterschiedlichen Objektfiles in ein kombiniertes Programm ermöglicht. Für einen Anfänger kann diese Diskrepanz zu einer zusätzlichen Herausforderung werden, für die er nicht die notwendige Zeit oder Motivation hat. Ein echter Compiler benötigt beispielsweiße noch ein Linkerscript bevor er arbeitet. Wenn man eine RISC-V CPU entwirft, möchte man eventuel lediglich simple Testprogramme von Addresse 0x00 ausführen und legt keinen Wert auf Adressbereiche. es soll ein Assembler für 32-bit RISC-V bereitgestellt werden, mit dem schnell, unkompliziert und ohne Annahmen RISC-V Assemblercode in Maschinenbefehle für den Upload in den CPU übersetzt werden kann.

5. Interaktion mit dem CPU - Wenn das Design über den Bitstream auf den FPGA bereitgestellt worden ist, wird der CPU ein Programm ausführen. Die Frage ist, wie man jetzt mit dem CPU interagiert. Das Ziel ist es nicht Peripherie wie Druckknöpfe, LEDs oder LCDs an den CPU anschließen, sondern mit dem CPU selbst zu kommunizieren. Nach Möglichkeit soll der CPU gestoppt und gestartet werden können. Der Zugriff auf Register soll möglich sein und der Zugriff auf den Speicher soll möglich sein. Dazu gibt es die Debug-Spezifikation für RISC-V (TODO: Referenz auf eine bestimmte Version der Debug-Spek hier einfügen! file:///C:/Users/lapto/dev/fpga/gowin_tang_nano/riscv_debug/doc/riscv-debug-release.pdf). Die Debug-Spezifikation beschreibt Komponenten um mit den Harts eines RISC-V CPU zu interagieren. Die Kommunikation kann über das JTAG-Protokoll ausgeführt werden. In diesem Bericht wird ein Teil der RISC-V Debug Spezifikation implementiert, gerade genug um die oben geforderten Punkte über eine JTAG DebugProbe auszuführen.

# 0. Einleitung zu RISC-V

RISC-V ist eine Instruction Set Architecture (ISA). Ein Instructionset Architecture ist eine Menge an Anweisungen, Registern und Datentypen. Damit beschreibt RISC-V keine konkrete CPU Architektur sondern gibt Befehle und Register vor, die auf einer konkreten Architektur ausführbar und vorhanden sein müssen, damit dieses System RISC-V konform ist. Laut der RISC-V homepage (Quelle: https://riscv.org > about > faq > Who uses an ISA?) ist eine ISA auch im Zuge der Leere einsetzbar damit Stunden die Wirkungsweiße eines Computers verstehen lernen. RISC-V wurde daher auch vor dem Hintergrund der Leere erstellt.

Damit steht RISC-V in Konkurrenz mit dem x86 Instructionset (Chips von Intel, AMD und weiteren), dem ARM Instructionset (Chips von STM32, Renesas, NXP, Qualcomm und andere) und allen anderen definierten Instructionsets (AVR, Itanium (IA-64), MIPS, Z-80 und viele weitere). Die Besonderheit von RISC-V ist das Lizenzmodel. Das Lizenzmodel besteht aus der Erlaubnis zur freien Benutzung und damit der Abwesenheit jeglicher Lizenzkosten (Quelle: https://riscv.org/about/faq/#:~:text=There%20is%20no%20fee%20to%20use%20the%20RISC%2DV%20ISA. In google eingeben: https://riscv.org > about > faq > What is the license model ).

RISC-V ist an der Universität UC Berkeley entwickelt worden. Dabei ist RISC-V aus dem Wissenschatz erstellt worden, den die Beteiligten im Zuge der vier Vorgängeprojekte (RISC-I bis RISC-4) sammeln konnten und heißt damit sinnigerweiße RISC-V (Quelle: https://riscv.org > about > faq > Why is it called RISC-V).

RISC-V hat in den letzten Jahren weitere Fortschritte gemacht. Das Tripple-A Spiel "The Witcher 3" lässt sich mit Einschränkungen auf einem RISC-V System (https://milkv.io/pioneer) ausführen. RISC-V Mainline Support wurde Linux im Jahre 2022 hinzugefügt. Die 64 Bit Variante von RISC-V hielt im Jahre 2023 Einzug in den Linux-Kernel (Quelle: https://en.wikipedia.org/wiki/RISC-V)

Die RISC-V ISA ist keine monoithische Spezifikation. Das angewandte Prinzip ist, dass ein Kern von Funktionen für eine gewisse Bit-Breite (XLEN) vorhanden sein muss, der dann durch Extensions erweitert werden kann. Beispiele für Kerne sind RV32I, RV64I und RV128I die Integer-Operationen mit jeweilgen Registerbreiten von 32, 64 und 128 Bit unterstützen. Extensions fügen dem System Floating-Point Unterstützung, Komprimierte Anweisungen, Vector-Mathematik, Kryptografie, Atomic-Operationen und viele weitere Funktionen hinzu.

In dieser Studienarbeit wird ein Teil des Kerns RV32I umgesetzt. Dieser Umfang kann durch weitere Entwicklungstätigkeit immer weiter bis zum vollem Umfang von RV32I ergänzt werden wenn notwendig. Als Extensions wird die Debug-Spezifikation hinzugefügt.

# 1. Auswahl der Hardware

- Lattice IceStick
- GOWIN TangNano 9k
- Digilent  ARTY S7
- DE 112

Kriterien: 
 - RAM; 
 - LUTs - Passt ein RISC-V Design auf den FPGA
 - Formfaktor (passt es auf den Tisch, kann man es leicht in einem Rucksack mitnehmen z.B. zwischen Hochschule und Wohnung)
 - Wieviel Perihperie hat es (Hat es PMOD, LEDs, Breakout Pins).
 - Anschaffungskosten
 - Freie Software

# 2. Auswahl der FPGA-Entwicklungstools

Kriterien zur Bewertung von FPGA Entwicklungstools

- Installationsplattenplatz (100-te GB sind schlecht!)
- Unterstützung von Simulationstools und Traceviewer on board
- Geschwindigkeit der Synthese (allgemeine Performance des Tools)
- Fehlererkennung der Synthese (logische Loops werden von Yosys nicht erkannt! Vom professionellen Tool schon)
- Editorqualität (go to definition, highlight von gehovertem Symbol, ...)

Da diese Studienarbeit Lösungen für den Student in einem der unteren Semester sucht, muss davon ausgegangen werden, dass dieser Student keine High-End Hardware zur Verfügung hat um erste Tests mit Hardwarebeschreibungssprachen zu machen und auch nicht bereit ist oder in der finanziellen Situation ist um sich High-End Hardware zu kaufen. Das wahrscheinlichste Szenario ist, dass die Hardware ein Laptop mittlerer Leistungsklasse mit einem Windows-Betriebssystem ist. Im folgenden werden die Messungen auf einem AMD Ryzen 7 PRO 4750U mit 32GB RAM. Die acht Kerne (16 Threads) haben einen Basistakt von 1,7 GHz und einen Boosttakt von 4,1 GHz. Der Prozessor besitzt 512 KB L1 Cache, 4 MB L2 Cache und 8 MB L3 Cache. Die Messungen werden unter Windows 11 Pro, 24H2 (OS build 26100.4349) ausgeführt. 

# Lattice iCEstick (https://www.latticesemi.com/icestick)
Der iCEstick der Firma Lattice ist ein FPGA im USB-Stick Format. Damit nimmt er kaum Platz auf dem Schreibtisch ein und kann leicht transportiert weren. Der Anschaffungspreis liegt bei etwa 130-150 Euro. Damit ist der Lattice iCEstick vergleichsweiße teuer. Die Peripherie weißt leider nur wenige Breakout Pins auf, dafür besitzt das Board einen einzigen PMOD Header und 5 LEDs, sowie einen Infrarot IrDA Sensor. Der iCEstick besitzt einen Lattice iCE40HX-1k FPGA chip (https://www.mouser.de/ProductDetail/Lattice/iCE40HX1K-TQ144?qs=F9A14TELRMtiYSwGl6R%2Fcw%3D%3D&srsltid=AfmBOopRdilmfbmh3HyTAYo1qr89NC4w5Ca6M5ykeBUMYd6rbPP2OnCq). Auf dem FPGA hat ein kleiner RISC-V CPU Platz (siehe https://github.com/BrunoLevy/learn-fpga und das FemotRV Projekt). Die offizielle IDE ist iCEcube2 und kann auf Microsoft Windows ausgeführt werden. Der Download von iCEcube2 ist 700MB groß und zur Installtion werden 880MB benötigt. Damit ist das Softwarepacket insgesamt vergleichsweiße klein. Zum Programmieren des Bitstream wird die Diamond Programmer Software verwendet, der den Bitsream in das OnBoard SPI Flash schreibt. Die iCEcube2 Software benötigt einen Lizenz zur Ausführung. Die Lizenz wird auf Anfrage an nicht-kommerzielle Entwickler und Start-Ups ausgegegben. Normalerweiße kostet diese Lizenz Geld. 

Als Alternative zur Software des Herstellers kann die OpenSource Toolchain Yosys (https://github.com/YosysHQ/yosys) verwendet werden. Yosys kann in einer für Windows vorgefertigten Version von https://yosyshq.net/yosys/download.html heruntergeladen werden. Yosys ist ein Sammlung an Kommandozeilentools um Verilog zu Synthetisieren, eine Bitstream zu erzeugen und den Bitstream auf die unterstützten FPGAs zu laden. Vorteile von Yosys sind der schnelle und unkomplizierte Download, der mit 303 MB sehr kompakt ist. Ein weiterer Vorteil ist die relativ schnelle Synthese-Zeit. Die Nachteile von Yosys sind die mangelhafte Erkennung und Ausgabe kritischer Fehler und die fehlende Option IPs einzusetzen. Der Nachteil ohne IP ist, dass ein Speicherblock vom Tool als Speicher erkannt werden muss. Diese Erkennung führt das Tool implizit automatisch aus und der Benutzer muss hoffen, dass sein Design als Speicher erkannt wird. Es gibt Vorgegebene Verilog Designs, die Yosys als Speicher erkennen soll. Nicht immer funktioniert die Erkennung automatisch. Wenn ein Speicher nicht als Speicher IP erkannt wird, wird er Bitstream nicht durch Hardware im FPGA implementiert werden. Wenn diese Situation eintritt, synthetisiert Yosys Speicher durch Logikblöcke und belegt damit direkt große Mengen an Resourcen auf dem FPGA, die dann nicht mehr für echte Logik zur Verfügung stehen! Um die Speicherhardware auf dem IceStick wirklich zu verwenden ist einiges an Erfahrung notwendig, die ein Anfänger wahrscheinlich nicht aufweißen kann. Diese Probleme traten während der Arbeit an dieser Studienarbeit auf und haben sehr viel Zeit gekostet. Letztendlich wurde auf ein anders Board mit anderer IDE umgestiegen.

Fazit zum IceStick mit Yosys: Die Verwendung ist für einen Anfänger zu kompliziert. Da kritische Fehler vom Werkzeug nicht automatisch erkannt werden, tappt ein Anfänger in die Falle Quellcode zu schreiben, der zwar synthetisiert, aber auf dem FPGA dann nicht funktioniert. Das erschwerte Erstellen von Speicher führt dazu, dass ein Anfänger daran scheitert einen RISC-V CPU einfach zu erstellen. Eine detailierte Einarbeitung in Yosys unter Aufsicht eines erfahrenen Mentors würde diese Situation wahrscheinlich entschärfen. Im Selbststudium steht diese Option allerdings nicht zur Wahl. Es wird Anfängern mit einem knappen Zeitrahmen nicht empfohlen mit Yosys zu beginnen.

# GOWIN Tang Nano 9K
Das Board an sich lässt sich für etwa 25 bis 60 Euro kaufen, je nachdem welches zubehör ausgewählt wird. Das Board ist damit vergleichsweiße günstig. Die IDE lässt sich einfach und kostenfrei herunterladen. Der Download der Education Version ist mit 413 MB vergleichsweiße klein und kann auf Microsoft Windows ausgeführt werden. 

Fazit: Es zeigt sich, dass die Arbeit mit dem GOWIN Tang Nano 9K Board am ehesten der Arbeit mit einem Arduino gleicht. Die IDE ist simpel und erste Verilog Module lassen sich schnell umsetzen und auf das Board laden. Die Synthese erfolgt sehr schnell, was die Wartezeiten gering hält. Dabei erkennt die Synthese viele relvante Fehler und gibt Warnungen und Fehler aus! Die IDE hat eine Bibliothek für IP-Cores, um z.B. einfach Speicher synthetisieren zu lassen. Es gibt einige gut dokumentierte Beispiele auf der Homepage des Produkts. Für einen Anfänger ist dieses Board gut geeignet, da er in der Lernphase sehr viele Fehler machen wird und die unkomplizierte und schnelle Deployment des Board damit einen großen Vorteil darstellt.


Fazit:
Tang Nano 9K wird für schnelle Tests verwendet. Das System wird letzendlich auf dem Arty S7 integriert.

# 3. Erlernen der HDL Verilog

TODO

# 4. Erstellen des Assemblers

Um die korrekte Funktionsweiße des RISC-V CPU zu testen, muss ein Programm im Instruction-Memory des CPU abgelegt werden, damit der CPU diese Anweisungen ausführt. Die Daten, die im Hauptspeicher erwartet werden sind die Anweisung der Maschinensprache. Die Umwandlung von Assembler-Anweisungen in Maschinen Sprache wird Kodierung genannt. Ein Assembler hat die Aufgabe RISC-V Assembly Anweisungen zu Kodieren. Die RISC-V ISA definiert exakt, wie die Kodierung ablaufen muss. 

Die Instruktionen des RV32I Kerns sind in sechs Gruppern (RISBUJ). Einige Instruktionen verwenden Register (Register, R) andere enthalten Parameter aus Daten, die direkt in die Instruction einkodiert werden (Immediate, I). Andere Instruktionen sind für Verzweigungen auf Basis einer Bedingung (Branches, B) und Sprünge ohne Bedingung (Jumps, J) zuständig. Instruktionen die in den Speicher schreiben gehören der Store (S) Gruppe an. Die U Instruktionen werden verwendet um 32 bit Werte in Register zuladen, was sich mit einem 32 bit weiten Anweisungsformat gar nicht beschreiben lässt. U Instruktionen erlauben daher nur Immediate Wert aus 20 bit und füllen die fehlenden 12 bit implizit mit 0 auf.

Es wird ein Assembler in der Programmersprache Java erstellt. Dafür gibt es mehere Gründe. Java lässt sich (nach der Installation eines JRE oder JDK) auf jedem Bebtriebssystem ausführen. Die Assembler und Compiler aus der GNU toolchain sind nicht ohne weiteres auf Windows ausführbar. Ein weiters Argument ist, dass es ein Simples Tool ohne viele Parameter geben soll um Test-Programm schnell und einfach zu übersetzten. Echte Assembler sind komplizierter zu bedienen und verwenden immer auch ein spezifische Memory Layout für einen Target und fügen extra Instruktionen für den Target hinzu. Diese zusätzlichen Instruktionen werden von dem eigenen simplen CPU wahrscheinlich gar nicht unterstützt und das kodierte Programm kann dann nicht verwendet werden. Hier soll es lediglich um ein Assembler für einen sehr simplen RISC-V CPU gehen. Der Assembler kodierte die Anweisungen, bis auf leichte Optimierungen, so wie sie eingegeben worden sind. Es gibt einen Online Assembler unter https://riscvasm.lucasteske.dev/. Der Nachteil dieses Assembler ist es, dass er 64 bit RISCV Instruktionen für RV64I ausgibt ohne dass dies irgendwo auf der Seite erwähnt wird. Wenn man einen RISC-V CPU mit eine RV32I Kern erstellt, dann kann dieser Online-Assembler nur eingeschränkt verwendet werden.

An den Assembler ist eine Emulator angeschlossen, der das kodierte Programm direkt ausführen kann. Damit kann wird die Gültigkeit des Programms erst lokal verifiziert um zu verhindern, dass das Programm auf den CPU geladen wird obwohl es an sich fehlerhaft ist. Wenn man ein fehlerhaftes Programm auf dem CPU ausführt, dann kann man in der Entwicklungsphase nicht unterscheiden ob das fehlerhafte Verhalten von dem CPU oder von dem Programm stammt und es werden eventuell Fehler an Stellen gesucht, an denen es gar keine Fehler gibt. Dabei kann viel Zeit verloren werden wodurch diese Situation vermieden werden muss.

Der Assembler liest Dateien mit RISC-V Assembler Anweisungen ein:

```
__main:
loop_start:
    addi x5, x0, 0x0
    addi x6, x0, 0x0
    lui x7, 0
    addi x7, x7, 2

busy_loop_start:	
    beq x5, x7, 0xC             # if (x5 == x7) jump to loop_end (pc relative jump of +12 bytes)
    addi x5, x5, 1
    jal x0, busy_loop_start     # jal loop head (pc relative jump back -8 bytes)

busy_loop_end:
    lw x6, 52(x0)
    xori x6, x6, 1
    sw x6, 52(x0)

    jal x0, loop_start
```

Der Assembler benötigt das Label __main um den Haupteinsprungpunkt zu finden, damit er diese Adresse an den Emulator geben kann und der Emulator die Ausführung dort im Speicher beginnt. Für den RISC-V CPU auf dem FPGA sollte __main immer so gelegt werden, dass seine Adresse mit 0x00 zusammenfällt, also ganz am Anfang des Listing.

Die Assembler Instruktionen werden dann durch einen Parser basierend auf einer Grammatik für RISC-V Assembly geparst. Der Weg über das Parsing wurde gewählt, da RISC-V Assembly ganze Anweisungsbäume erlaubt. Ein Beispiel ist die Anweisung "jal   ra, pc - 176;" Diese Anweisungsbäume sind nur schwer durch einen manuel entwickelten Quellcode zu verarbeiten, der dann letztendlich über lange Zeit fehlerbehaftet sein wird. Auf lange Sicht macht der Einsatz einer Grammatik Sinn und spart Zeit.

Das Ergebnis des Parsing ist ein Parse-Tree. Ein Visitor wird über den Parse-Tree geführt. Der Visitor (RISCASMExtractingOutputListener) befüllt einzelne Instanzen der Klasse AsmLine mit den Werten, die er aus den RISC-V Assembler Zeilen ziehen kann. An dieser Stelle liegt jetzt die RISC-V Assembly Datei in Form einer Liste von AsmLine Objekten vor.

Der nächste Schritt ist das Anwenden einer ersten einfachen Optimierung. Wenn sich im Quellcode lui und addi Anweisungen befinden, kann ein Paar dieser Anweisungen durch eine LI (Load Immediate) Pseudo Instruktion ersetzt werden. Dies erscheint zunächst kontraproduktiv, da ein Assembler eher Pseudoinstruktionen auflösen als erstellen soll. Es ergibt nur dann Sinn, wenn man weiß, das zu einem späteren Zeitpunkt wieder Pseudoinstruktionen aufgelöst werden. Während der Auflösung hat der Assembler die Freiheit die LI Instruktion zu optimieren und es wird eventuel anstelle des lui, addi Paares nur ein lui ausgegeben. Durch dieses Verhalten korrigiert der Assembler eventuel unnötig eingefügt Instruktionen durch den Programmierer. Diese Optimierung wurde übernommen, da andere Assembler das gleicher Verhalten haben und sich die Ergebnisse des eigenen Assemblers nur mit anderen Assemblern gegenprüfen lassen, wenn man diese Optimierung auch anwendet.

TODO: Füge eventuell Beispiel einer optimierung ein:

Im Folgenden erstellt der Assembler eine Tabelle von .equ Konstanten mit deren Werten, damit er Konstanten in Parametern, Expressions und Labeln durch numerische Werte ersetzen kann.

TODO Füge eventuel .equ Beispiel ein, das die Ersetzung zeigt.

Nach dem ersetzen der Konstanten werden Pseudo-Anweisungen aufgelöst. Beispielsweiße wird ein NOP Pseudo-Anweisung durch ein ADDI Befehl ersetzt, wobei die ADDI Operation keinen Effekt haben darf. Es wird eine ADDI Instruktion ausgegeben, die den Wert 0 auf das ZERO Register addiert! Dieser Ablauf ändert absolut nichts am Zustand der CPU außer, dass ein CPU Zyklus verbraucht wird und sich der Program Counter (PC) auf die folgende Anweisung verschiebt.

In diesem Abschnitt wurde zuvor erwähnt, dass LI Anweisung später aufgelöst werden. Dieser Zeitpunkt ist jetzt gekommen. Nachdem Auflösen der anderen Pseudo-Instruktionen wird nun auch LI aufgelöst. Dabei wird geprüft, ob die LI Anweisung ein Label als Immediate-Wert verwendet. Wenn ein Label verwendet wird, dann wird die Adresse des Labels ermittelt und die Differenz zwischen der aktuellen Adresse und der Label-Adresse gebildet. Wenn die Differenz mit einem simplen LUI geladen werden kann, dann wird nur ein LUI ausgegeben, ansonsten wird eine Kombination aus ADDI und LUI ausgegeben.

Jetzt wird der Call-Optimizer aufgerufen. Wenn eine Routine angesprungen wird, hat der Programmierer meherer Möglichkeiten den Sprung zur Routine zu implementieren. Wenn die Routine innerhalb eines Megabyte relative zur aktuellen Adresse zu finden ist (near call), dann reicht eine einzige JAL Instruktion. Wenn die Routine außerhalb des Megabyte zu finden ist (far call) dann wird eine Kombination aus AUIPC und JALR ausgegeben.

Nachdem alle Pseudo-Instruktionen durch echte Instruktionen ersetzt worden sind und alle Optimierer entschieden haben, ob sie ein oder zwei Instruktionen ausgeben möchten, liegt eine Liste mit ausschließlich "echten" Instruktionen vor. Auf dieser Liste werden jetzt relative Offsets ersetzt. Relative Offsets werden mit f und b und einem Label-Namen notiert. Der Assembler muss im Falle von f das erste folgende Label finden und im Falle von b das erste vorhergehende Label finden. Das gefundene Label wird dann durch seine Adresse ersetzt.

Siehe folgendes Beispiel von https://marz.utk.edu/my-courses/cosc230/book/example-risc-v-assembly-programs/ in dem 1f und 1b verwendet wird. 1 ist hier ein Label, dass doppelt verwendet wird, einmal in f-Richtung und einmal in b-Richtung.

```
.section .text
.global strlen
strlen:
    # a0 = const char *str
    li     t0, 0         # i = 0
1: # Start of for loop
    add    t1, t0, a0    # Add the byte offset for str[i]
    lb     t1, 0(t1)     # Dereference str[i]
    beqz   t1, 1f        # if str[i] == 0, break for loop
    addi   t0, t0, 1     # Add 1 to our iterator
    j      1b            # Jump back to condition (1 backwards)
1: # End of for loop
    mv     a0, t0        # Move t0 into a0 to return
    ret                  # Return back via the return address register
```

Im Anschluss werden Expression-Trees ausgerechnet und in die Instruktion eingesetzt. Danach werden die Modifier HI() und LO() ersetzt.

Der allerletzte Schritt ist es jetzt den Encoder auf jede AsmLine anzuwenden welcher MaschinenCode für die AsmLine ausgibt.

Damit hat der Assembler die Eingabe and en RISC-V CPU erzeugt.


# 5. Architektur des Pipelined RISC-V CPU

TODO

# 6. RISC-V Debug Spezifikation und JTAG-DebugProbe on Arduino

Quellen: 
[100] https://five-embeddev.com/riscv-debug-spec/v0.13-release/core_debug.html
[101] https://riscv.org/wp-content/uploads/2024/12/riscv-debug-release.pdf

Die Interaktion mit einem Computer erfolgt über Ein- und Ausgabeperipherie. Dabei sind auf den Entwicklungsboards üblicherweiße Slider, Knöpfe, LEDs, Displays oder 7-Segment-Anzeigen vorhanden. Möchte man direkt über den Zustand des CPU oder der an den Systembus angeschlossen Module wie Speicher oder UARTs informiert werden, sind die Perihperie und simple Tests meist nicht detailiert genug.

Einen direkten Zugriff auf die Register und den Speicher erhält man über einen Debugger. Ein Debugger kann nur funktionieren, wenn die Zielhardware Funktionen bereitstellt, die der Debugger nutzen kann. Der Debugger muss über eine Infrastruktur mit dem CPU verbunden werden.

Der RISC-V Debug Support ist keine eigene Extension. Die Spezifikation für den Debug Support heißt "RISC-V External Debug Support" [101] und definiert alle Funktionen und wird im Folgenden Debug-Spezifikation genannt.

Um die Debug-Spezifikation zu verstehen ist es wichtig unterschiedliche Ebenen voneinander zu trennen, da ansonsten schnell Verwirrung entsteht. Die Ebenen, die zu trennen sind, sind die konkrete Implementierung der Infrastruktur (hier JTAG und Wishbone) und die Module die Spezifisch für RISC-V definiert worden sind (DTM, DMI, DM und Harts).

TODO: Hier Bild von Seite 6 der Debug_Spec darstellen.

Um den RISC-V Anteil zu beschreiben, beginnen wir auf dem Endbenutzergerät (PC oder Laptop), auf dem die Debugger-Software läuft. Im Zuge dieser Studienarbeit werden Python-Skripte erstellt, die die Aufgabe eines Debuggers übernehmen. Die Debugger-Software spricht mit einer Debug-Probe, welche die Signale auf das Entwickler-Board überträgt, auf dem das RISC-V System läuft. Die Debug-Spezifikation bezeichnet das RISC-V System als RISC-V Platform. Die RISC-V Debug Spezifikation gibt nicht vor, welche Technologie zur Übertragung der Signale verwendet werden muss. Dazu später mehr.

Innerhalb der RISC-V Platform wird die Verbindung zunächst am Debug Transport Module (DTM) terminiert. Es kann in einer RISC-V Platform mehrere DTM Implementierungen geben. Beispielsweiße könnte ein DTM über USB sprechen, eine andere Implementierung eines DTM über JTAG. An dieser Stelle bleibt die konkrete Implementierung noch abstrakt und spielt erstmal keine Rolle für die weitere Beschreibung der Debug-Spezifikation.

Der DTM verwendet das Debug-Module-Interface (DMI) um mit einem oder mehreren Debug-Modulen zu sprechen. Das Debug-Module-Interface sieht Register und Befehle im DTM vor, die eine Kommunikation mit dem DM auslösen. Diese Befehle sind definiert. Der Debugger muss diese Befehle schicken um bestimmte Aktionen innerhalb der RISC-V CPU auszulösen.

Die RISC-V CPU besteht aus mindestens einem Hart. Ein Hart besitzt Hardware um Instruktionen auszuführen (Eine Pipeline samt Registern und eine oder mehrere ALU). Fortschrittliche RISC-V CPUs können viel Harts enthalten um echtes Multithreading zu ermöglichen. Ein Debug-Module (DM) ist für einen oder mehrere Harts zuständig. Eine RISC-V Platform kann eine oder mehrer DM enthalten.

Der DTM muss im ersten Schritt die Anzahl der DMs ermitteln und dann DMs auswählen. Die momenten ausgewählten DMs erhalten dann Befehle vom DTM, die sie dann auf ihren Harts ausführen sollen. Mit diesen Befehlen kann ein DTM kann die DMs anweißen ihre Harts zu pausieren, zu reseten und weiterlaufen zu lassen. Es ist auch möglich die Register der Harts zu lesen zu schreiben und über den Systembus mit dem Speicher (RAM für Instruktionen und Daten) zu interagieren und den Speicherinhalt zu lesen und zu schreiben.

Die RISC-V Platform, die im Zuge dieser Arbeit erstellt wird, besitzt einen einzigen Hart um die Komplexität für Anfänger handhabbar zu gestalten. Aus dem gleichen Grund wird nicht jeder Teil der Debug-Spezifikation implementiert. Das Zählen und das Auswählen der DMs wird nicht implementiert. Es wird implizit von einem einzigen Hart ausgegangen der automatisch immer ausgewählt und damit immer das Ziel aller Befehle ist.

Die noch zu beschreibenden Teile sind die konkrete Implementierung zur Übertragung der Daten zwischen der Debug-Probe und dem DTM innerhalb der RISC-V Platform. Wie oben beschrieben, muss die Debugger-Software DMI-Befehle im DTM auslösen. Dazu muss sie diese DMI-Befehle übertragen. Innerhalb dieser Studienarbeit wird dazu JTAG verwendet.

JTAG ist ein Protokoll das zum Testen von Hardware eingesetzt wird. Es erlaubt neben dem Ausführen von Hardwaretestabläufen auch das Schreiben in Register und in den Speicher und wird daher auch häufig eingesetzt um Mikrokontroller-Firmware zu flashen. Innerhalb der JTAG-Beschreibung gibt es den TAP. Der TAP befindet sich im Zielsystem und terminiert dort die JTAG Verbindung. Da diese Aufgabe beinahe Deckungsgleich mit dem DTM aus der RISC-V Debug Spezifikation ist, wird ein JTAG TAP als RISC-V DTM ausgeführt oder alternativ wird ein TAP direkt mit dem DTM verbunden. 

JTAG ist in der Lage Register zu beschreiben. Die Interaktion zwischen dem JTAG Protokoll und dem RISC-V DTM besteht also darin, dass der JTAG-TAP in die Register des DTM schreibt. Die RISC-V Debug Spezifikation ist so ausgeführt, dass das Beschreiben eins Registers Aktionen direkt startet. Damit ist JTAG ein perfektes Protokol um die RISC-V Debug Spezifikation auszuführen.

Die RISC-V Platform ist jetzt also in der Lage DMI Befehle zu starten. Das Debug-Module-Interface (DMI) ist das Protokoll zwischen einem DTM und mehrern DMs. Die Frage ist, wie wird diese Datenübertragung in Hardware Implementiert? Die RISC-V Debug Spezifikation überlässt diese Detail der Implementierung und macht absolut keine Vorgaben. In der Debug-Spezifikation wird nirgends definiert, wie eine DMI Transaktion gestartet oder gestoppt wird. Der verwendet Wortlaut ist absichtlich abstrakt und es wird von Lesen und Schreiben gesprochen. Im Zuge dieser Studienarbeit wird die Interkation über den Wishbone Bus implementiert. Der Wishbone Bus ist gut dokumentiert (TODO: B4 Spec hier verlinken) und ohne Lizenzgebühren einsetzbar. Der Wishbone Bus ist von der Komplexität her minimal im Vergleich zu anderen Bussystemen (AMBA-Bus, AXI-Bus, ...).

Für einen einfachen Debugger sollen folgende Funktionen implementiert werden:
- Hart stoppen, reseten und starten und im Single Step modus ausführen sowie die normale Ausführung wieder anfnehmen.
- Register lesen schreiben
- Speicher lesen schreiben

Mit diesen Funktionen kann Maschinen code auf den RISC-V CPU geladen werden und das Programm kann im Single-Step Betrieb ausgeführt werden.

Die JTAG-Debug Probe wird für erste Tests über einen Arduino DUE (3.3 Volt-System) und über Bit-Banging implementert. Python Skripte werden auf dem PC ausgeführt und sprechen mit dem Arduino über ein simples Datenaustauschprotokoll. Der Debugger besteht aus einzelnen Pyhton Skripten.

Um den Hart zu stoppen, hat der DM Kontroller über die Hardware Clock-Source, die den Hart mit einem Taktsignal verorgt. Wenn die Clock-Leitung unterbrochen wird, dann ist der Hart gestoppt. Zum Single-Step Betrieb generiert der DM ein eigenes Clock-Signal und führt dem Hart dieses Clock-Signal zu. Wenn der Hart fortgesetzt wird, dann wird die Hardware Clock-Source wieder zugeführt.

## JTAG State Machine

## RISCV Abstract Commands